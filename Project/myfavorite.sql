/*
SQLyog Ultimate v12.08 (64 bit)
MySQL - 5.7.1-m11 : Database - myfavorite
*********************************************************************
*/

/*!40101 SET NAMES utf8 */;

/*!40101 SET SQL_MODE=''*/;

/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;
CREATE DATABASE /*!32312 IF NOT EXISTS*/`myfavorite` /*!40100 DEFAULT CHARACTER SET utf8 */;

/*Table structure for table `fans` */

DROP TABLE IF EXISTS `fans`;

CREATE TABLE `fans` (
  `username` varchar(100) NOT NULL COMMENT '被关注的人',
  `usernameimg` varchar(100) DEFAULT 'http://localhost:1234/static/uploaduserimg/timg.jpg' COMMENT '被关注的人的头像',
  `followuser` varchar(100) NOT NULL COMMENT '粉丝',
  `followuserimg` varchar(100) DEFAULT 'http://localhost:1234/static/uploaduserimg/timg.jpg' COMMENT '粉丝的头像'
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

/*Data for the table `fans` */

insert  into `fans`(`username`,`usernameimg`,`followuser`,`followuserimg`) values ('郝天恒','http://localhost:1234/static/uploaduserimg/timg.jpg','崔宫健','http://localhost:1234/static/uploaduserimg/timg.jpg'),('崔宫健','http://localhost:1234/static/uploaduserimg/timg.jpg','郝天恒','http://localhost:1234/static/uploaduserimg/timg.jpg'),('崔宫健1','http://localhost:1234/static/uploaduserimg/timg.jpg','郝天恒','http://localhost:1234/static/uploaduserimg/timg.jpg'),('崔宫健2','http://localhost:1234/static/uploaduserimg/timg.jpg','郝天恒','http://localhost:1234/static/uploaduserimg/timg.jpg'),('测试1','http://localhost:1234/static/uploaduserimg/timg.jpg','郝天恒','http://localhost:1234/static/uploaduserimg/timg.jpg'),('测试2 ','http://localhost:1234/static/uploaduserimg/timg.jpg','郝天恒','http://localhost:1234/static/uploaduserimg/timg.jpg'),('测试3','http://localhost:1234/static/uploaduserimg/timg.jpg','郝天恒','http://localhost:1234/static/uploaduserimg/timg.jpg'),('郝天恒','http://localhost:1234/static/uploaduserimg/timg.jpg','测试1','http://localhost:1234/static/uploaduserimg/timg.jpg'),('郝天恒','http://localhost:1234/static/uploaduserimg/timg.jpg','测试2','http://localhost:1234/static/uploaduserimg/timg.jpg'),('郝天恒','http://localhost:1234/static/uploaduserimg/timg.jpg','测试3','http://localhost:1234/static/uploaduserimg/timg.jpg');

/*Table structure for table `login` */

DROP TABLE IF EXISTS `login`;

CREATE TABLE `login` (
  `uid` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键',
  `role` int(11) DEFAULT '0' COMMENT '管理者',
  `userimg` varchar(100) DEFAULT 'http://localhost:1234/static/uploaduserimg/timg.jpg' COMMENT '用户头像',
  `username` varchar(100) NOT NULL COMMENT '用户名',
  `passwd` varchar(100) NOT NULL COMMENT '密码',
  `fansnumber` int(11) DEFAULT '0' COMMENT '粉丝数量',
  `followusernumber` int(11) DEFAULT '0' COMMENT '关注的人数',
  `ctime` datetime DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`uid`,`username`,`passwd`)
) ENGINE=InnoDB AUTO_INCREMENT=48 DEFAULT CHARSET=utf8;

/*Data for the table `login` */

insert  into `login`(`uid`,`role`,`userimg`,`username`,`passwd`,`fansnumber`,`followusernumber`,`ctime`) values (1,1,'http://localhost:1234/static/uploaduserimg/timg.jpg','admin','123',0,0,'2020-11-19 08:34:47'),(2,1,'http://localhost:1234/static/uploaduserimg/timg.jpg','admin123','123',0,0,'2020-11-19 08:43:26'),(3,1,'http://localhost:1234/static/uploaduserimg/timg.jpg','admin2','password123',0,0,'2020-11-19 08:43:52'),(26,0,'http://localhost:1234/static/uploaduserimg/timg.jpg','郝天恒','123',1,6,'2020-11-26 22:56:02'),(41,0,'http://localhost:1234/static/uploaduserimg/timg.jpg','崔宫健','123',1,1,'2020-12-02 21:13:36'),(42,0,'http://localhost:1234/static/uploaduserimg/2020-12-14_17-4-41_88599.jpg','郝天恒1','123',0,0,'2020-12-04 14:19:54'),(43,0,'http://localhost:1234/static/uploaduserimg/timg.jpg','郝天恒2','123',0,0,'2020-12-04 14:20:04'),(44,0,'http://localhost:1234/static/uploaduserimg/timg.jpg','郝天恒3','123',0,0,'2020-12-04 14:20:15'),(45,0,'http://localhost:1234/static/uploaduserimg/timg.jpg','崔宫健1','123',1,0,'2020-12-04 14:20:23'),(46,0,'http://localhost:1234/static/uploaduserimg/timg.jpg','崔宫健2','123',1,0,'2020-12-04 14:20:31'),(47,0,'http://localhost:1234/static/uploaduserimg/timg.jpg','崔宫健3','123',0,0,'2020-12-04 14:20:41');

/*Table structure for table `save` */

DROP TABLE IF EXISTS `save`;

CREATE TABLE `save` (
  `username` varchar(100) NOT NULL,
  `textid` int(11) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

/*Data for the table `save` */

insert  into `save`(`username`,`textid`) values ('郝天恒',1),('郝天恒',2),('郝天恒',3),('郝天恒',4),('郝天恒1',5),('郝天恒2',5);

/*Table structure for table `text` */

DROP TABLE IF EXISTS `text`;

CREATE TABLE `text` (
  `textid` int(11) NOT NULL AUTO_INCREMENT,
  `titleimg` varchar(100) DEFAULT 'http://localhost:12345/static/uploadtextimg/timg.jpg' COMMENT '文章图片',
  `userimg` varchar(100) DEFAULT 'http://localhost:1234/static/uploadusertimg/timg.jpg' COMMENT '作者头像',
  `username` varchar(100) NOT NULL,
  `type` varchar(100) NOT NULL,
  `title` varchar(100) NOT NULL,
  `text` text NOT NULL,
  `savenumber` int(11) NOT NULL DEFAULT '0',
  `ctime` datetime DEFAULT CURRENT_TIMESTAMP,
  KEY `id` (`textid`)
) ENGINE=InnoDB AUTO_INCREMENT=65 DEFAULT CHARSET=utf8;

/*Data for the table `text` */

insert  into `text`(`textid`,`titleimg`,`userimg`,`username`,`type`,`title`,`text`,`savenumber`,`ctime`) values (1,'http://localhost:12345/static/uploadtextimg/timg.jpg','http://localhost:1234/static/uploadusertimg/timg.jpg','郝天恒','css','第一篇文章','这是第一篇文章',1,'2020-11-27 16:45:26'),(2,'http://localhost:12345/static/uploadtextimg/timg.jpg','http://localhost:1234/static/uploadusertimg/timg.jpg','郝天恒','html','第二篇文章','这是第二篇文章',1,'2020-11-28 15:06:26'),(3,'http://localhost:12345/static/uploadtextimg/timg.jpg','http://localhost:1234/static/uploadusertimg/timg.jpg','郝天恒1','css','第三篇文章','这是第三篇文章',1,'2020-11-30 10:10:21'),(4,'http://localhost:12345/static/uploadtextimg/timg.jpg','http://localhost:1234/static/uploadusertimg/timg.jpg','郝天恒2','综合','第四篇文章','这是第四篇文章',1,'2020-11-30 10:11:26'),(5,'http://localhost:12345/static/uploadtextimg/timg.jpg','http://localhost:1234/static/uploadusertimg/timg.jpg','崔宫健','js','第五篇文章','这是第五篇文章',0,'2020-12-03 20:24:31'),(6,'http://localhost:12345/static/uploadtextimg/timg.jpg','http://localhost:1234/static/uploadusertimg/timg.jpg','崔宫健1','综合','第六篇文章','这是第六篇文章',0,'2020-12-03 20:25:04'),(15,'http://localhost:12345/static/uploadtextimg/timg.jpg','http://localhost:1234/static/uploadusertimg/timg.jpg','郝天恒','html','关于html','一、VS的相关设置\r\n1.设置\r\n文件夹折叠：设置-功能-资源管理器，Compact Folders 把前面的对号去掉\r\n\r\n文件图标-设置-文件图标主题-选择器（vscode自带2个，）\r\n\r\n目录结构的缩进长度：点击小齿轮图标 -> 设置 -> 工作台 -> 外观 -> Tree:Indent 设置长度（数字越大缩进距离越大）\r\n\r\n设置字体大小：点击小齿轮图标 -> 设置 -> 文本编辑器 -> 字体 设置字体大小\r\n\r\n二、html基础\r\n2.1HTML代码的组成\r\n文档声明\r\n注释\r\nHTML元素(标签)\r\n2.2文档声明\r\n<!doctype html>\r\n1\r\n告知浏览器使用标准模式解析页面\r\n\r\n2.3注释\r\n<!-- 注释-->\r\n<!-- \r\n    注释\r\n    我爱你\r\n-->\r\n1\r\n2\r\n3\r\n4\r\n5\r\n注释：对代码进行说明（浏览器读取的时候，不会解析注释）\r\n\r\n保存快捷键：ctrl+s\r\n\r\n2.4HTML标签（元素）\r\n特点：\r\n\r\n每个html标签有不同的功能。\r\nhtml标签有双标签也有单标签。\r\nhtml标签具有属性，而且不同的HTML标签会具有不同的属性\r\nHTML标签里面可以嵌套其他的HTML标签，也可以嵌套文本内容（双标签）\r\nHTML的标签名和属性名不区分大小写的，建议小写\r\n2.5如何掌握一个html标签\r\n掌握该HTML标签的功能（语义）\r\n掌握该标签是单标签还是双标签\r\n掌握该标签具有哪些属性，以及属性的值怎么写\r\n2.6结构标签\r\n<!doctype html>\r\n<!--作为整个元素的根标签-->>\r\n<html>\r\n    <!--页面头部-->\r\n    <head>\r\n        <!--页面的标签-->\r\n        <title>我的美好生活</title>\r\n        <!--设置字符及编码-->\r\n        <meta charset=\"utf-8\">   \r\n    </head>\r\n    <!--页面主体-->\r\n    <body>\r\n        \r\n    </body>\r\n\r\n</html>\r\n1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n7\r\n8\r\n9\r\n10\r\n11\r\n12\r\n13\r\n14\r\n15\r\n16\r\n标签名	语义	属性	单标签或双标签\r\nhtml	页面的根源素		双标签\r\nhead	页面的头部\r\n设置页面的描述信息		双标签\r\nbody	页面主体\r\n页面中的内容都写在body中		双标签\r\ntitle	设置页面标题，\r\n写在head标签中		双标签\r\nmeta	设置字符集编码，写在head标签的里面	charset:是一种字符集编码，一般建议utf-8	单标签\r\n2.7格式排版标签\r\n标签名	语义	属性	单标签还是双标签\r\nh1-h6	一级标题到6级标题		双标签\r\np	段落		双标签\r\nhr	分隔符		单标签\r\nlorem数字按tab占行（写了多少个数字就会有多少个单词）\r\n\r\n一般设置宽度width，不设置height，怕失真（width和height设置一个即可）\r\n\r\n2.8图片\r\n标签名	语义	属性	双标签还是单标签\r\nimg	图片	src:值是图片的地址\r\nwidth:设置图片的宽度，值是数字\r\nheight:设置图片的高度，值是数字	单标签\r\n图片地址的规则：以写的html文件为中心，确定图片文件相对于html文件处在什么样的位置\r\n\r\n2.9超链接标签\r\n标签名	语义	属性	双标签还是单标签\r\na	超链接	href：设置超链接要跳转的目的地址	双\r\n中间可以使文字，也可以是图片\r\n\r\n2.10表单标签\r\n标签名	语义	属性	双标签还是单标签\r\ninput	单行输入框	type：设置输入框的类型，默认取值text\r\nplaceholder:设置提示文字	单标签\r\ntextarea	多行文本输入框（文本）	placeholder:设置提示文字	双标签\r\nbutton	按钮		双标签\r\n2.11列表标签\r\n标签	语义	属性	单标签还是双标签\r\nul	无序列表		双标签\r\nli	列表项，写在ul的里面		双标签\r\n三、总结\r\nhtml 页面的根标签 双标签\r\nhead 页面头部 双标签\r\nbody 页面主体   双标签\r\ntitle 页面标题   双标签\r\nmeta 设置字符集编码 属性：charset 单标签\r\nh1~h6 内容标题，一级到六级 双标签\r\np 段落 双标签\r\nhr 分隔符 单标签\r\n\r\nimg 图片标签 属性：src,width,height 单标签\r\na 超链接标签   属性：href   双标签\r\ninput  单行文本输入框 属性：type,placeholder 单标签\r\ntextarea 多行文本输入框（文本域）  属性：placeholder 双标签\r\nbutton   按钮 双标签\r\n\r\nul 无序列表    双标签\r\nli  列表项，写在ul里面   双标签\r\n\r\ndiv 布局结构标签，用于布局页面结构 双标签',2,'2020-12-10 08:58:25'),(16,'http://localhost:12345/static/uploadtextimg/timg.jpg','http://localhost:1234/static/uploadusertimg/timg.jpg','崔宫健','css','关于CSS','1、子div和父div的margin设置。\r\n\r\n   <div class=\"a\"><div class=\"b\"></div></div>当设置.b {margin: 30px auto 0}时，b盒子并没有距离a盒子顶端30px，反而a盒子也被影响离顶端30px。\r\n\r\n   原因：所有毗邻的（同级或嵌套的盒元素，且没有被非空内容、padding、border 或 clear 分隔开）两个或更多盒元素的margin将会合并为一个margin共享之。\r\n\r\n   方法1：在父DIV的css加上“overflow:hidden;”。（最佳）\r\n\r\n   方法2：在父DIV的css加上“border:1px solid transparent;”。\r\n\r\n   方法2：父级设置padding（破坏非空白的折叠条件）\r\n\r\n   方法3：在父DIV的css加上float或者position:absolute。（浮动或绝对定位不参与margin的折叠）\r\n\r\n2、视频播放。\r\n\r\n   页面添加video，注意视频编码格式，兼容IE是AVC，不是mpeg4格式。\r\n\r\n3、权重\r\n\r\n   两个类选择器同时作用于一个元素上，权重高的生效。\r\n\r\n   <div class=\"a b\">hello world</div>\r\n\r\n   <div class=\"b a\">hello world</div>\r\n\r\n   .a.b{ color: red; }\r\n\r\n   .b.a{ color: blue; }\r\n\r\n   最后两个颜色都是blue【权重高低与.a.b/.b.a无关（注意：类选择器之间没有间隔），但和它们的先后顺序有关】\r\n\r\n4、选择器\r\n\r\n   <button class=\"btn\">选项</button>，在设置样式时，应该是button.btn(没有间隔)，不应该是button .btn\r\n\r\n5、定位方案：普通流、浮动、定位\r\n\r\n   普通流：元素在html文档中自上而下、从左往右布局，传统的html文档文本布局。行内元素水平排列，行内占满会自动换行；块级元素会被渲染成独立一行，除非指定。\r\n\r\n   浮动（right、left）：元素会脱离文档流，它后面的元素会占据它的位置，也就是图层关系，浮动元素在上方；但文字段落不会占据浮动元素的位置（在浮动元素下方），而是围绕它，可以理解为没有脱离文本流吧（嗯！个人理解）。\r\n\r\n   绝对（absolute/fixed）：元素不仅会脱离文档流（整体脱离），还会脱离文本流。定位元素对其他元素没有造成影响，元素具体位置由坐标（top、left、bottom、right）表示。\r\n\r\n   相对（relative）：不会脱离文档流，设置的TRBL元素的文档空间还是会被保留，不会影响其他元素的位置。但设置margin就会对其他元素有所影响。\r\n\r\n\r\n\r\n6、BFC（块级格式化上下文）\r\n\r\n   Formatting Context(格式化上下文)：页面中一块渲染区域，有自己的渲染规则，决定其子元素如何定位，和其他元素的关系及相互作用。\r\n\r\n   BFC(Blocking Formatting Contexts)，属于定位方案的普通流。具有BFC特性的元素可以看成是被隔离的独立容器，容器内元素不会在布局上影响外面元素，主要作用是让元素本身（包括它的子元素）能够正确的计算自己的宽高。触发BFC特征的条件有：\r\n\r\n          1）body根元素；\r\n\r\n          2）浮动元素：float（left、right）；\r\n\r\n          3）绝对定位元素：position（absolute、fixed）；\r\n\r\n          4）显示框类型：display（inline-block、table-cells、flex）；\r\n\r\n          5）内容溢出框：overflow（hidden、auto、scroll）；\r\n\r\n     BFC具有以下特征：\r\n\r\n     1）避免外边距重叠：两个div元素处于同一个BFC容器中（如body），即使设定两个div的margin值为100px，它们的距离也只有100px，而不是200px。通过把两个div放在不同BFC容器可以解决该问题（但对于overflow来说，不同的容器只是设置overflow属性就行[父元素]，子元素设置的margin值才不会被折叠）。注意：但是并不是BFC就能避免折叠，如果上下相邻元素共同设置overflow，即使触发BFC，但是上下margin还是会发生折叠。完全不会发生折叠情况只有触发BFC元素的子集（float、position、display）。\r\n\r\n     2）包裹浮动流（清除浮动），全部浮动子元素也不会引起容器高度塌陷，也就是说包含块会把浮动元素的高度也计算在内，所以不用清除浮动来撑起高度（包含浮动的父元素没有添加具体的高度，在添加BFC特征后，父元素的高度是浮动元素的高度）——计算高度。\r\n\r\n     3）阻止元素被浮动元素覆盖（实现两列适应布局也可以，左宽固定[float]，右宽自适应[overflow]，要设置高度）\r\n\r\n7、文字\r\n\r\n   文字自带前后边距，前后距离为0时要设置为margin： 0.\r\n\r\n8、transition、transform、animation\r\n\r\n   1）transition: 用于缩写过渡属性：效果属性名、效果完成的时间、效果速度曲线、效果延迟开始时间与结束时间（all、0、ease、0）。transition实现的动态效果是一组属性到另一组属性的过程（两个样式，最初属性和最终属性，而transition放在最初属性中）\r\n\r\n         transition: property  duration  timing-function  delay;   \r\n\r\n   2）transform: 应用 2D 或 3D 转换(旋转、缩放、移动或倾斜)。 transform: none | transform-functions;\r\n\r\n         transform-functions: rorate、scale、translate、skew。【rotate的旋转度数，正数为顺时针，负数为逆时针】\r\n\r\n         ◆rotateX()：元素沿着x轴线旋转，水平宽度不会变，但高度由于转动会变，也就是看起来在Y轴方向上变化。\r\n\r\n         ◆rotateY()：元素沿着y轴线选装，垂直高度不会变，但宽度由于转动会变，也就是看起来x轴方向上会变化。\r\n\r\n        下图如rotateX()、rotateY()：\r\n\r\n     \r\n\r\n       ①transform-style：flag | preserve-3d；规定如何在三维空间（3D）中呈现被嵌套元素（要先使用transform属性）。\r\n\r\n           flag：表示所有子元素在2D平面呈现。\r\n\r\n           persever-3d：表示所有子元素在3D空间中呈现。\r\n\r\n       ②transform-origin：表示元素转换的基点。\r\n\r\n           transform-origin：X-axis  Y-axi;(2D) \r\n\r\n           transform-origin：X-axis Y-axis  Z-axis;(3D)\r\n\r\n           X( left、center、right、length、%），Y（top、 center、bottom、 length、%），Z（length）。\r\n\r\n         \r\n\r\n        更多详情，参考：http://www.cnblogs.com/xiaohuochai/p/5350254.html\r\n\r\n     3）animation: 用于设置元素动画属性：要绑定到选择器的keyframe名称、动画时间、动画速度曲线、动画何时开始、动画播放次数、动画是否轮流方向传播。animation可在多组属性之间进行动态效果的变换过程。\r\n\r\n animation：name   duration    timing-function   delay    iteration-count    direction;\r\n\r\n9、absolute元素居中\r\n\r\n    要居中的前提是子元素的父元素必须是定位元素，如relative、absolute、fixed；先设置子元素（left：50%），然后在设置margin-left负值，值为子元素宽的一半（如子元素的width: 200px，则margin-left: -100px;）。\r\n\r\n10、overflow并不一定能隐藏所有元素\r\n\r\n     overflow： hidden不能隐藏包含块是整个视区的元素（如视区是body时）。作为position：absolute元素的的包含块只能是最近的具有position：absolute、position：relative的元素，如果任何元素都不具有，则包含块则是body元素。所以当具有overflow：hidden的元素，其后代元素具有position： absolute属性，且该属性的包含块是body或者是overflow的父级元素时，则不能隐藏元素。 \r\n\r\n<!DOCTYPE html>\r\n<html>\r\n    <head>\r\n        <meta charset=\"UTF-8\">\r\n        <title></title>\r\n        <style>\r\n            .parentAbsolute {\r\n                /*position: absolute; 也可以*/  \r\n                position: relative;\r\n            }\r\n            \r\n            .testOverflow {\r\n                width: 100px; height: 100px; background: lightblue; overflow: hidden; margin: 0 auto; } .testAbsolute, .absoChild { position: absolute; width: 200px; height: 50px; background: lightpink; } .absorelaParent { position: relative; } </style> </head> <body> <p>overflow属性并不总是能够隐藏所有子元素，当具有position：absolute元素的包含块是body元素或者是overflow：hidden的父元素时，则子元素不会被隐藏</p> <div class=\"parentAbsolute\"> <div class=\"testOverflow\"> <div class=\"testAbsolute\"> 包含块是overflow:hidden的父元素 </div> </div> </div> <br> <div class=\"testOverflow\"> <div class=\"absoChild\"> 包含块是body </div> </div> <br> <div class=\"testOverflow\"> <div class=\"absorelaParent\"> <!-- 因为absolute会脱离文档流啊 --> <div class=\"absoChild\">父元素:<br>relative才隐藏</div> </div> </div> </body> </html>\r\n\r\n11、关于absolute的相对位置的参考点\r\n\r\n      position:absolute是相对于父元素定位的，如果父元素设定padding，则子元素的参考起始点会改变，如父元素padding： 50px，则子元素的top: 0,left:0应该在距离父元素的top:50,left:50处。\r\n\r\n　　如果把position属性值是absolute的元素A放入一个position属性值是relative的元素B中，则B就成为A的容器元素，而A将在B的显示区域里按absolute方式进行摆放。\r\n\r\n12、文档流和文本流的区别 \r\n\r\n      普通流：元素按照自上而下、自左往右的HTML文档布局显示\r\n      文本流：由一系列字符构成，可由多行构成，每一行由一个换行符终止。\r\n             文本流将数据读取，在普通流中根据自左向右、自上而下的布局输出显示。\r\n             <body>...</body>、<head>...</head>...是一个流\r\n\r\n       块级元素会占据float元素的空间，比如div、p，但标签里的文字不会；\r\n       元素的display属性为inline-block或inline的不会占据float元素位置\r\n       文字、图片、视频不会占据float元素的位置,即使被块级元素如div包裹着，但块级元素会跑去占据float元素的位置。\r\n\r\n<!DOCTYPE html>\r\n<html>\r\n    <head>\r\n        <meta charset=\"UTF-8\">\r\n        <title></title>\r\n        <style>\r\n            .a {\r\n                width: 200px; height: 110px; border: 1px solid #000; } .a1 { float: left; width: 50px; height: 50px; background: lightblue; } .a2 { width: 50px; height: 50px; background: lightpink; } .a3 { display: inline-block; width: 50px; height: 50px; background: lightpink; } </style> </head> <body> <div class=\"a\"> <div class=\"a1\">块级元素</div> <span class=\"a2\"></span> </div> <div class=\"a\"> <div class=\"a1\">inline-block</div> <span class=\"a3\"></span> </div> <div class=\"a\"> <div class=\"a1\">&lt;p&gt;</div> <p style=\"margin: 0;\">张雨生--口是心非、大海</p> </div> <!-- 设置图片,即使<img>元素包裹于div中，图片(文字、视频)仍然不会占据float位置，但div会占据 --> <div class=\"a\"> <div class=\"a1\">&lt;img&gt;</div> <img src=\"../images/border-image.png\"> </div> </body> </html>\r\n其实有个疑问，我想把四个大的div水平排列的，利用position：relative和absolute结合都没有解决这个问题。\r\n\r\n13、可变、行内、块级元素\r\n\r\n     可变元素：为根据上下文语境决定该元素为块元素或者内联元素。\r\n\r\n　  applet——java applet\r\n\r\n　  bdo——bidi override\r\n\r\n 　 button——按钮\r\n\r\n      del——删除文本\r\n\r\n      iframe——inline frame\r\n\r\n      ins——插入文本\r\n\r\n      map——图片区块(map)\r\n\r\n      object——object对象\r\n\r\n      script——客户端脚本\r\n\r\n      行内元素：\r\n\r\n　　a——锚点\r\n\r\n　　abbr——缩写\r\n\r\n　　acronym——首字（h5不支持，可用<abbr>代替）\r\n\r\n　　br——换行\r\n\r\n　　big——大字体\r\n\r\n　　cite——引用\r\n\r\n　　code——计算机代码（引用源码）\r\n\r\n　　dfn——定义字段\r\n\r\n　　em——强调\r\n\r\n　　font——字体设定（不推荐）\r\n\r\n　　i——斜体\r\n\r\n　　img——图片\r\n\r\n　　input——输入框\r\n\r\n　　kbd——定义键盘文本\r\n\r\n　　label——表格标签\r\n\r\n　　q——短引用\r\n\r\n　　s——中划线（不推荐）\r\n\r\n　　strike——中划线\r\n\r\n　　samp——定义范例计算机代码\r\n\r\n　　select——项目选择\r\n\r\n　　small——小字体文本\r\n\r\n　　span——常用内联容器。定义文本区块\r\n\r\n　　strong——粗体强调\r\n\r\n　　sub——下标\r\n\r\n　　sup——上标\r\n\r\n　　textarea——多行文本输入框\r\n\r\n　　tt——电传文本\r\n\r\n　　u——下划线\r\n\r\n　　var——定义变量\r\n\r\n       块级元素：\r\n\r\n　　address——地址\r\n\r\n　　article——文字内容\r\n\r\n　　aside——伴随内容\r\n\r\n　　audio——音频播放\r\n\r\n　　blockquote——块引用\r\n\r\n　　canvas——绘制图形\r\n\r\n　　dd——定义列表中定义条目描述\r\n\r\n　　dl——定义列表\r\n\r\n　　fieldset——form控制组\r\n\r\n　　form——交互表单\r\n\r\n　　figcaption——图文信息组标题\r\n\r\n　　figure——图文信息组\r\n\r\n　　footer——区段尾或页尾\r\n\r\n　　h1、h2、h3、h4、h5、h6-——标题\r\n\r\n　　header——区段头或页头\r\n\r\n　　hgroup——标题组\r\n\r\n　　hr——水平分隔线\r\n\r\n　　noscript——可选脚本内容（对于不支持script的浏览器显示此内容）\r\n\r\n　　menu——菜单列表\r\n\r\n　　noframes——frames可选内容（不支持frame的浏览器显示此内容）\r\n\r\n　　ol——有序列表\r\n\r\n　　output——表单输出\r\n\r\n　　p——段落\r\n\r\n　　pre——格式化文本\r\n\r\n　　section——一个页面片段\r\n\r\n　　label——表格\r\n\r\n　　tfoot——表脚注\r\n\r\n　　ul——非排序列表\r\n\r\n　　video——视频\r\n\r\n14、form表单中的button组件\r\n\r\n     在form表单中，直接使用button组件需要标明button的type属性，不然点击没有效果。也可以<input type=\"button\" value=\"按钮\">\r\n\r\n15、Colors合法颜色值\r\n\r\n　　十六进制颜色：#RRGGBB（红、绿、蓝） #000000~#FFFFFF\r\n\r\n　　RGB颜色：#RGB（红、绿、蓝） #000~#255、#0%~#100%\r\n\r\n　　RGBA颜色：#RGB（红、绿、蓝，alpha）#000~#255、#0%~#100%、alpha：0.0~1.0\r\n\r\n　　HSL颜色：HSL（色相、饱和度、亮度）——使用色彩圆柱坐标表示\r\n\r\n　　　　　　   色相：是指在色轮上的程度（从0~360），0/360是红色、120是绿色、240是蓝色；\r\n\r\n　　　　　　　饱和度：（0%~100%）是一个百分比，0%意味着灰色和100%的阴影，是全彩；\r\n\r\n　　　　　　　亮度：（0%~100%）是一个 百分比，0%是黑色，100%是白色；\r\n\r\n　　HSLA颜色：HSLA（色相、饱和度、亮度、alpha），alpha：0.0~1.0\r\n\r\n　　预定义/跨浏览器的颜色名称：147颜色是在HTML和CSS颜色规范预定义的颜色名称（17个标准色加上130多个其他颜色）。\r\n\r\n16、关于浮动\r\n\r\n　　非浮动元素包含浮动元素时，要高度自适应需在非浮动元素中添加overflow：hidden清除浮动。\r\n\r\n17、ul自带的margin属性\r\n\r\n　　去除列表的自带属性是ul {margin: 0}，而不是ul li { margin: 0}。\r\n\r\n18、字体增大或缩小时布局\r\n\r\n　　控制字体变大或缩小时，应该给字体所在容器设置样式【display: inline-block/float: left/right，并添加宽度width】，当字体变换时，如需换行，可以整体排列好。\r\n\r\n19、元素并排设置\r\n\r\n　　当有两个元素并列时，可以使用float设置元素的水平位置，可以同时同一方向，或者left、right，再margin其他属性调整，清除浮动就好。',1,'2020-12-10 08:58:41'),(17,'http://localhost:12345/static/uploadtextimg/timg.jpg','http://localhost:1234/static/uploadusertimg/timg.jpg','崔宫健','react','测试','<p>123123</p>',0,'2020-12-11 15:21:31'),(18,'http://localhost:12345/static/uploadtextimg/timg.jpg','http://localhost:1234/static/uploadusertimg/timg.jpg','崔宫健','react','测试','<p>&nbsp;&nbsp;&nbsp;&nbsp;123123</p>',0,'2020-12-11 15:35:37'),(19,'http://localhost:12345/static/uploadtextimg/timg.jpg','http://localhost:1234/static/uploadusertimg/timg.jpg','郝天恒','好物推荐','好物推荐1','没有什么想推荐的，嘿嘿嘿',0,'2020-12-12 17:14:23'),(20,'http://localhost:12345/static/uploadtextimg/timg.jpg','http://localhost:1234/static/uploadusertimg/timg.jpg','郝天恒1','好物推荐','好物推荐2','你猜猜看我想推荐什么',0,'2020-12-12 17:15:09'),(21,'http://localhost:12345/static/uploadtextimg/timg.jpg','http://localhost:1234/static/uploadusertimg/timg.jpg','郝天恒','测试','测试','删除删除删除',0,'2020-12-14 11:03:45'),(22,'http://localhost:12345/static/uploadtextimg/timg.jpg','http://localhost:1234/static/uploadusertimg/timg.jpg','郝天恒','测试','测试2','删除删除啊哈收纳盒粗化手段和端深度',0,'2020-12-14 11:04:30'),(8,'http://localhost:12345/static/uploadtextimg/timg.jpg','http://localhost:1234/static/uploadusertimg/timg.jpg','郝天恒','js','我从2019年开始的十大JavaScript文章','<p>javascript文章</p><p>自从它作为笨拙的前端脚本语言开始以来，JavaScript已经走了很长一段路。 我们在2019年看到了JavaScript领域的一些重大发展，包括React钩子和函数式编程概念的广泛采用，向TypeScript的稳定转换以及前端框架生态系统中React的持续统治。</p><p>在取得所有这些进步的同时，可能很难跟上这些变化。 因此，我整理了一份清单，列出了我在过去一年中阅读的十大JavaScript文章。</p><p>我相信这些文章对于开发人员来说很重要。 其中许多是由有影响力JavaScript开发人员和思想领袖编写的； 其他人只是有很棒的内容。 我是根据内容和质量选择它们的，并且未按任何特定顺序列出它们。</p><h2><a></a><a></a><a href=\"https://dev.to/heroku/my-top-10-javascript-articles-from-2019-1da6?ref=hackernoon.com#1-the-state-of-javascript-2019\"></a>1. JavaScript状态2019</h2><p><a href=\"https://2019.stateofjs.com/?ref=hackernoon.com\">JavaScript 2019状态</a>是描述2019年JavaScript世界的统计数据和事实的集合。</p><p>不将Sacha Greif和RaphaëlBenitte的作品包括在2019年有影响力JavaScript出版物清单中将是一个巨大的疏忽。 2019年JavaScript状态描述了JavaScript的所有内容：</p><ul><li>React在前端框架生态系统中的持续流行</li><li>TypeScript在数量上的兴起</li><li>JavaScript的受众特征</li><li>新的后端框架</li><li>和更多</li></ul><p>对于希望掌握最抢手技能的新开发人员和经验丰富的专业人士（招聘人员通常称为“ JS忍者”）而言，这是一年一度的必读内容。</p><h2><a></a><a></a><a href=\"https://dev.to/heroku/my-top-10-javascript-articles-from-2019-1da6?ref=hackernoon.com#2-a-complete-guide-to-useeffect\"></a>2. useEffect完整指南</h2><p><a href=\"https://overreacted.io/a-complete-guide-to-useeffect/?ref=hackernoon.com\">完整的useEffect指南</a>是Dan Abramov对如何正确使用功能性React.js中的useEffect钩子的看法。</p><p>如果不引用Dan Abramov的工作，那也将是一个不完整的清单。 从2019年开始在useEffect（）上的这篇文章只是必读。 Dan描述了为什么以及如何将类组件和生命周期方法（例如componentDidMount）重构为带有挂钩的功能组件。 除了官方的React.js文档之外，如果您有兴趣并通过钩子学习现代React，这也是一个不错的起点。</p><h2><a></a><a></a><a href=\"https://dev.to/heroku/my-top-10-javascript-articles-from-2019-1da6?ref=hackernoon.com#3-thinking-in-react-hooks\"></a>3.在React Hook中思考</h2><p><a href=\"https://wattenberger.com/blog/react-hooks?ref=hackernoon.com\">在React Hooks</a>中<a href=\"https://wattenberger.com/blog/react-hooks?ref=hackernoon.com\">思考，</a>描述了如何改变使用现代功能模式编写React.js的方式。</p><p>本篇和下一篇文章延续了函数式编程的主题以及2019年React钩子的出现。Amelia Wattenberger的文章更广泛地讲解了React.js和JavaScript中函数式编程模式的“为什么”。</p><h2><a></a><a></a><a href=\"https://dev.to/heroku/my-top-10-javascript-articles-from-2019-1da6?ref=hackernoon.com#4-why-isnt-x-a-hook\"></a>4.为什么X不是钩子？</h2><p><a href=\"https://overreacted.io/why-isnt-x-a-hook/?ref=hackernoon.com\">为什么X不是钩子？</a>让您深入了解React.js钩子实现和模式背后的动机。</p><p>丹·阿布拉莫夫（Dan Abramov）在2019年入选该榜单的第二篇文章是对React.js钩子开发基础哲学的讨论。 Hooks席卷了React.js社区，并且无疑是2019年的亮点之一; 本文说明了从事这些工作的人们背后的一些动机。</p><h2><a></a><a></a><a href=\"https://dev.to/heroku/my-top-10-javascript-articles-from-2019-1da6?ref=hackernoon.com#5-functional-javascript-traversing-trees-with-a-recursive-reduce\"></a>5.功能性JavaScript：使用递归约简遍历树</h2><p><a href=\"https://jrsinclair.com/articles/2019/functional-js-traversing-trees-with-recursive-reduce/?ref=hackernoon.com\">功能性JavaScript：使用递归</a>约<a href=\"https://jrsinclair.com/articles/2019/functional-js-traversing-trees-with-recursive-reduce/?ref=hackernoon.com\">简遍历树</a>是一个有关如何使用JavaScript中的功能性编程解决现实问题的案例研究。</p><p>詹姆斯·辛克莱（James Sinclair）在2019年进行的有关功能JavaScript的公共工作是社区的真正财富。 他的所有文章都很棒，但是这篇文章因其在前端Web开发中的优雅性和实用性而对我脱颖而出。 如果您不熟悉Scala之类的功能语言，那么其中的某些概念一开始似乎很难掌握，但对于编写可测试，可扩展和可组合JavaScript至关重要。 对于希望编写更多功能JS的开发人员来说，这是另一本必读的文章。</p><h2><a></a><a></a><a href=\"https://dev.to/heroku/my-top-10-javascript-articles-from-2019-1da6?ref=hackernoon.com#6-javascript-clean-code-best-practices\"></a>6. JavaScript Clean Code：最佳做法</h2><p><a href=\"https://devinduct.com/blogpost/22/javascript-clean-code-best-practices?ref=hackernoon.com\">JavaScript Clean Code-Best Practices</a>是一个很好的资源，可帮助您使用JS最佳实践来提高代码质量。</p><p>在阅读了Milos Protic的这篇文章并吸收了它的智慧之后，您的同事会惊叹于您新发现的编写干净JS的能力。 这部分内容很多，都是适用，可行和正确的。 请在2020年这样编写JavaScript代码！</p><h2><a></a><a></a><a href=\"https://dev.to/heroku/my-top-10-javascript-articles-from-2019-1da6?ref=hackernoon.com#7-option-chaining\"></a>7.期权链</h2><p>自异步/等待以来，<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining?ref=hackernoon.com\">选项链接</a>是JavaScript的最佳补充。</p><p>我包含了此文档在MDN上发布的关于选项链的文档，因为我认为该功能是（如果不是）2019年对香草JavaScript的最重要的新增功能之一。选项链和无效合并是惊人的生活质量改善，我认为所有JavaScript开发人员应该使用。 我个人每天会多次使用此语言功能，这使我的JS代码更简洁，更易读。</p><h2><a></a><a></a><a href=\"https://dev.to/heroku/my-top-10-javascript-articles-from-2019-1da6?ref=hackernoon.com#8-ive-forgotten-more-javascript-than-most-people-ever-learn\"></a>8.我忘记JavaScript比大多数人学到的更多</h2><p><a href=\"https://levelup.gitconnected.com/kyle-simpson-ive-forgotten-more-javascript-than-most-people-ever-learn-3bddc6c13e93?ref=hackernoon.com\">我忘了JavaScript比大多数人都学到的东西</a>吸引了社区思想领袖的大脑。</p><p>大多数JavaScript开发人员都会对Kyle Simpson进行有见地的采访，这是一个有趣的读物，他对Kyle Simpson的采访是“活着JavaScript经典，是开源精神的最真实体现”。 通过阅读原始JS代码，这是一个值得的间歇，而Simpson对语言的过去和未来的见解十分深刻。</p><h2><a></a><a></a><a href=\"https://dev.to/heroku/my-top-10-javascript-articles-from-2019-1da6?ref=hackernoon.com#9-design-patterns-in-modern-javascript-development\"></a>9.现代JavaScript开发中的设计模式</h2><p><a href=\"https://levelup.gitconnected.com/design-patterns-in-modern-javascript-development-ec84d8be06ca?ref=hackernoon.com\">现代JavaScript开发中的设计模式</a>具有来自JS上下文的Singleton，Observer和Facade模式。</p><p>克里斯蒂安·波斯莱克（Kristian Poslek）关于设计模式的热门文章在2019年脱颖而出。尽管他没有提供具体的示例和代码，但我认为他的见解足够有价值，可以列入此列表。 对于那些想知道学术设计模式如何在现实世界中的JS实现中占有一席之地的人来说，这是一个有趣的读物。</p><h2><a></a><a></a><a href=\"https://dev.to/heroku/my-top-10-javascript-articles-from-2019-1da6?ref=hackernoon.com#10-fix-memory-problems\"></a>10.解决内存问题</h2><p><a href=\"https://developers.google.com/web/tools/chrome-devtools/memory-problems?ref=hackernoon.com\">修复内存问题</a>可帮助我们使用Chrome devtools调试Node.js / JavaScript内存泄漏。</p><p>Kayce Basques讨论了开发人员如何使用Google Chrome浏览器快速调试JavaScript和Node.js内存问题。 我之所以写这篇技术文章，是因为考虑到Chrome在消费市场上的主导地位以及作为Web开发者选择的浏览器的优势，我认为此处讨论的工具非常重要且很有帮助。 （请参阅<a href=\"https://2019.stateofjs.com/?ref=hackernoon.com\">JavaScript 2019的状态</a>。）在大型JavaScript代码库中，通常很难诊断内存泄漏，并且这些工具过去对我有帮助。</p><p>希望您花一些时间阅读上面列出的文章。 我发现这些文章是JavaScript领域2019年最具影响力，最有见地的作品，希望您能同意。</p><p><em>先前发布在https://dev.to/heroku/my-top-10-javascript-articles-from-2019-1da6</em></p><blockquote><p>翻译自:<a href=\"https://hackernoon.com/my-top-10-javascript-articles-from-2019-we463yfk\">https://hackernoon.com/my-top-10-javascript-articles-from-2019-we463yfk</a></p></blockquote><p>javascript文章</p>',0,'2020-12-14 15:10:32'),(11,'http://localhost:12345/static/uploadtextimg/timg.jpg','http://localhost:1234/static/uploadusertimg/timg.jpg','崔宫健','js','2020及新十年的顶级JavaScript框架和话题','<p>全文共<strong>7114</strong>字，预计学习时长<strong>21</strong>分钟</p><p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9qTmIwbXlnYjh4Q3J2bkxKbmFZeTFJaWFVZHhUT1lnZWtXSzd2V1RQY2VrT29GM0JSUlJtaWIwT0dmNlBpY3RMT0RVYlBmcEczYWtBOGs4eVNPejFqUUYzdy82NDA?x-oss-process=image/format,png\"></p><p>来源：Pexels</p><p>如果你想找一份与JavaScript相关的好工作，或者是了解2020以及新十年间的重要技术，请阅读本文，保证干货满满。<br></p><p><br></p><p>本文的重点不在于列举那些“最好的”、最受人喜爱的或最受欢迎的技术栈和框架——而是说明哪些栈和框架最有助于在2020及新十年间找到好工作。</p><p><br></p><p>笔者将研究一些数据，它们来源甚广：</p><p><br></p><p>l&nbsp; 按主题搜索的谷歌搜索趋势</p><p>l&nbsp; JS调查现状</p><p>l&nbsp; Stack Overflow调查</p><p>l&nbsp; Npm下载</p><p>l&nbsp; 汇总职位公告</p><p><br></p><p>以上指标都不完美，但是就笔者目的而言，npm下载次数和职位公告最为重要，总的来看，这些指标清晰一致地描绘了JavaScript的技术前景及趋势。基于这些指标选择框架来学习好吗？这取决于目标是什么。</p><p><br></p><p>清晰的目标——为求职者学习投资回报率——让这项任务比告知读者何为最佳要容易得多。虽然没有什么东西可以实现所有目的，但是客观地定义什么最有可能有助于达到某个特定的、具体的目标确实很容易。请看一些数据。</p><p><br></p><p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9QTFNBaHVFbEZ4bXl1ZjA0ckNGWE8walI5MGNTdnNUaWFkc1lmWVI0QjZMeUNCRXpnYTRJT1BpYkxEOUlORjNTdm16RThkdUQ0eFVDWXJZaHdHeGliSlA3dy82NDA?x-oss-process=image/format,png\"></p><h1><a></a><a></a><strong>首先，了解JavaScript</strong></h1><p><br></p><p>过于担心技术栈之前，先了解JavaScript以及怎样用它生成软件。若无法说明函数组合、对象组合和模块是什么，请点击此处。所有的软件开发都是组合：将复杂的大问题分解成可用软件构造块来解决的小问题：比如函数、对象、模块等等。这些解决方案经过组装之后形成了应用程序。新年伊始，请深入了解JavaScript和软件组合。</p><p><br></p><p>2019，React占据主导地位，2020，其地位依旧</p><p><br></p><p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9qTmIwbXlnYjh4Q3J2bkxKbmFZeTFJaWFVZHhUT1lnZWtiWTFhbEE3bkI4ck85VjdpYzFFWVZMMjMzU3Z0Q3NpY0hNWFc0UkF5ck9YdzhnMkNkQ0sySmVldy82NDA?x-oss-process=image/format,png\"></p><p>笔者喜欢npm下载指标，因为它可以很好地呈现框架的活跃使用情况*。由于用户在本地计算机上运行npm install，因此通常处于工业框架的下载情况会极其活跃。</p><p><br></p><p>注意：此处不包括jQuery，很多jQuery项目是不适用npm的旧项目，因此无论如何它都会被严重低估。Svelte包括在内，目的是为了提供一些关于其在市场中相对位置的见解，并解释它未出现在其余图表之中的原因——尚未有足够的数据支持Svelte在图表中进行有意义的展示。比如，它还不是谷歌搜索趋势中的可用主题。</p><p><br></p><p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9QTFNBaHVFbEZ4bXl1ZjA0ckNGWE8walI5MGNTdnNUaWFkc1lmWVI0QjZMeUNCRXpnYTRJT1BpYkxEOUlORjNTdm16RThkdUQ0eFVDWXJZaHdHeGliSlA3dy82NDA?x-oss-process=image/format,png\"></p><h1><a></a><a></a><strong>汇总职位公告</strong></h1><p><br></p><p>该图表统计了目前开放的职位公告，提到了某种特定的框架*。</p><p><br></p><p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9qTmIwbXlnYjh4Q3J2bkxKbmFZeTFJaWFVZHhUT1lnZWtDZjhQcVo4b3JXd2ljc1c3SjNwb0xuUWxhWllvQzkySmFpYUxPYjV1M1FPM1FpYjRMY2pJTXkwM2cvNjQw?x-oss-process=image/format,png\"></p><p>2019年12月由UI框架制作的董事会工作清单</p><p><br></p><p>与去年相比，React增强了领先优势，而Angular和jQuery都丧失了和Vue竞争的优势。以下是一张饼状图，展示了各框架的相对就业市场份额情况：</p><p><br></p><p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9qTmIwbXlnYjh4Q3J2bkxKbmFZeTFJaWFVZHhUT1lnZWtZWU1EN3RjSjQzNEtOUVRlQktZNHM4OWlhUGlhcmdoWjRDNTJLZ3k4clVpYUpBU2lhaENINE5ZUDVBLzY0MA?x-oss-process=image/format,png\"></p><p>顶级框架就业市场份额</p><p><br></p><p>JavaScript开发人员平均工资于2019年再次上涨，从原来的每年11.1万美元涨到11.4万美元（来源）。</p><p><br></p><p>*方法：在Indeed.com网站上求职。为去除误报，笔者将搜索与关键词“软件”配对的内容，加强相关性，然后乘以1.5（大概是使用关键词“软件”的编程职位列表和不使用该关键词的列表之间的区别。）所有的搜索引擎结果页面按日期排列，并抽查相关性。得出的数字并不是100%准确，但是对于本文中使用的相对近似值来说已经足够了。</p><p><br></p><p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9QTFNBaHVFbEZ4bXl1ZjA0ckNGWE8walI5MGNTdnNUaWFkc1lmWVI0QjZMeUNCRXpnYTRJT1BpYkxEOUlORjNTdm16RThkdUQ0eFVDWXJZaHdHeGliSlA3dy82NDA?x-oss-process=image/format,png\"></p><h1><a></a><a></a><strong>谷歌搜索趋势</strong></h1><p><br></p><p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9qTmIwbXlnYjh4Q3J2bkxKbmFZeTFJaWFVZHhUT1lnZWtaYlc2NWlhVWpBS1Z2bThZNWY1cW1ZaWJpYmljY0FPd0dSdG92aGRQUmowSmVwdk56QkplOFNncmh3LzY0MA?x-oss-process=image/format,png\"></p><p><br></p><p>意料之中的是，搜索兴趣*反映了就业市场份额，但存在一些有趣的差异。从图中可以清楚地看到，2017年至今，jQuery的搜索兴趣正在减弱，而Vue.js的搜索兴趣却呈现强劲的增长态势。搜索份额如下图：</p><p><br></p><p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9qTmIwbXlnYjh4Q3J2bkxKbmFZeTFJaWFVZHhUT1lnZWtKUUh1WWdVZUI3cWljdnNKSkxnbEgzaWNUVzZuQUpaRmNxQTFZcmF4cUcyYnlFWHlGTnFrRXRVUS82NDA?x-oss-process=image/format,png\"></p><p><br></p><p>与职位公告一样，React有很大的领先优势，吸引了前端框架36%的搜索量，紧随其后的是Angular（大约27%）和jQuery（25%）。对Vue.js的搜索兴趣要比它占有的职位市场份额大得多，但该数据在排名方面一般与职位市场数据一致。这一点看来已经被成功证实。</p><p><br></p><p>*方法：对于所有字词来说，数据都是按照主题而非检索项收集的，目的是从无关的关键字匹配中排除误报。</p><p><br></p><p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9QTFNBaHVFbEZ4bXl1ZjA0ckNGWE8walI5MGNTdnNUaWFkc1lmWVI0QjZMeUNCRXpnYTRJT1BpYkxEOUlORjNTdm16RThkdUQ0eFVDWXJZaHdHeGliSlA3dy82NDA?x-oss-process=image/format,png\"></p><h1><a></a><a></a><strong>未来值得关注的框架</strong></h1><p><br></p><p>越来越多的职位需要掌握React技能的人才，而不是Svelte或Vue这样的技能，它们虽然十分流行，但是应用却没有这么广泛（二者都获得了很高的满意度，但相比之下，行业采用率却低得多）。</p><p><br></p><p>学会Svelte或Vue可能很酷——但是如果目标是找工作，那么先学会React会有更高的胜算。</p><p><br></p><p>也就是说，在JavaScript现状调查2019中，Svelte和Vue都获得了颇高的用户满意度。过去，React的高用户满意度预示着它将比Angular更快获得收益，后者在当时占据主导地位，但满意度得分却相对较低。</p><p><br></p><p>2019年，React的用户满意度排名第一，达到89%。Svelte（88%）和Vue.js（87%——低于去年的91%）紧随其后。Svelte或Vue不太可能会抢走足够的React用户来提高自己的用户满意度，但是仍有大量Angular和jQuery用户可能选择Svelte或Vue，从而让Svelte和Vue在2020年实现强劲增长。</p><p><br></p><p>可以肯定的是，掌握React会提高2020年找到好工作并留在工作岗位的几率。</p><p><br></p><p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9QTFNBaHVFbEZ4bXl1ZjA0ckNGWE8walI5MGNTdnNUaWFkc1lmWVI0QjZMeUNCRXpnYTRJT1BpYkxEOUlORjNTdm16RThkdUQ0eFVDWXJZaHdHeGliSlA3dy82NDA?x-oss-process=image/format,png\"></p><h1><a></a><a></a><strong>TypeScript vs JavaScript</strong></h1><p><br></p><p>毫无疑问，在过去几年间，TypeScript实现了快速发展。JavaScript现状调查显示，89%的TypeScript用户会再次使用TypeScript，而66%的受调查者或使用TypeScript，或对其感兴趣（略低于去年的71%）。</p><p><br></p><p>虽然人们的兴趣十分浓厚，使用率似乎也在快速增长，但是职位市场对TypeScript的使用经验尚未有强烈的需求。只有约7%的JavaScript职位空缺在职位描述中提及TypeScript（来源）。在人事经理的期望中，JavaScript开发人员能够轻松使用TypeScript，所以他们有可能不会在职位启事中提到TypeScript，这就导致了该数字可能偏低。</p><p><br></p><p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9qTmIwbXlnYjh4Q3J2bkxKbmFZeTFJaWFVZHhUT1lnZWtIUnVlcUt5cDFPWTY0OXM3dThXRHdNdXdZd2Q4Q0d0SkNYWVNQVUtTc2xqNzJQVzQ4Mnl3NHcvNjQw?x-oss-process=image/format,png\"></p><p><br></p><p>笔者坚信，TypeScript语言的投资回报率可能较低甚至为负。它会对生产力不利，而不是提高生产力，而且如果已经应用TDD、代码审查、设计审查这样强大的漏洞预防措施，那么TypeScript编码就不太可能大幅减少漏洞的数量。</p><p><br></p><p>也就是说，TypeScript有不少优点，用户不应对其心生恐惧，或者只因公司要求使用TypeScript而不是JavaScript就拒绝某份工作。TypeScript是JavaScript的超集，因此JavaScript转换为TypeScript并不像学习一种截然不同的语言那样具有挑战性。</p><p><br></p><p>要想在2020年的求职市场中占据优势，学会TypeScript语言并不是必须的，但是TypeScript确实很有用，甚至对于标准的JavaScript来说也是如此。</p><p><br></p><p>笔者每天都用TypeScript为使用微软代码编辑器的JavaScript提供智能感知服务。该智能感知甚至可通过使用JSDoc（由可解释类型注释的TypeScript理解并解释）或外部d.ts文件增强，VS代码会自动为用户使用的模块获取TypeScript定义。</p><p>注意：多年以来，笔者一直使用TernJS和Atom，享受着类似的好处，但是这两者的配合使用缺少TypeScript+VS的代码维护和社区支持。</p><p><br></p><p>若未尝试过微软代码编辑器，可先从此开始。顺便说一下，VS代码在JS被调查地区中占据着JavaScript集成开发环境市场的主导地位，占据57%的市场份额（其次是网络风暴，占据14%的市场份额）。</p><p><br></p><p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9QTFNBaHVFbEZ4bXl1ZjA0ckNGWE8walI5MGNTdnNUaWFkc1lmWVI0QjZMeUNCRXpnYTRJT1BpYkxEOUlORjNTdm16RThkdUQ0eFVDWXJZaHdHeGliSlA3dy82NDA?x-oss-process=image/format,png\"></p><h1><a></a><a></a><strong>数据管理</strong></h1><p><br></p><p>Redux在状态管理器竞争中仍具有领先优势，但GraphQL和Apollo也正在获得客户的青睐和兴趣。预计2020年对GraphQL的使用会持续增长。</p><p><br></p><p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9qTmIwbXlnYjh4Q3J2bkxKbmFZeTFJaWFVZHhUT1lnZWt5dzhpYTB1Z2tsWGdvWXhXanpQSDNXMVBrY0o3VlE3TmoydU93c1RHamtpY2ZyM1dvV3FGSzhhdy82NDA?x-oss-process=image/format,png\"></p><p><br></p><p>也就是说，即使用户使用GraphQL，仍然有强有力的证据可以证明Redux状态管理器的能力，即使大家都不用Redux，他们也会因学习Redux而受益。</p><p><br></p><p>GraphQL是近年来流行的查询语言。它句法简单，但由于其用于全栈，且学习该语言需要学会怎样将其连接到数据存储层，因此令人望而生畏——不过值得付出努力。</p><p><br></p><p>在短期内，GraphQL不会完全取代JSONREST API。但是，2019年，它发展迅速，预计2020年会持续强劲增长。</p><p><br></p><p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9QTFNBaHVFbEZ4bXl1ZjA0ckNGWE8walI5MGNTdnNUaWFkc1lmWVI0QjZMeUNCRXpnYTRJT1BpYkxEOUlORjNTdm16RThkdUQ0eFVDWXJZaHdHeGliSlA3dy82NDA?x-oss-process=image/format,png\"></p><h1><a></a><a></a><strong>后端</strong></h1><p><br></p><p>Express是占主导地位的Node框架，其满意度很高，2020年也不会出现实力强大的挑战者，但是随着无服务器的兴起，笔者预计Express会在新十年间逐渐丧失主导地位。</p><p><br></p><p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9qTmIwbXlnYjh4Q3J2bkxKbmFZeTFJaWFVZHhUT1lnZWt2RVJaMmhkVE1RUjFWQTlVNUJ1dlM5RkxoZ0YwaWNtMEluemljZWRsRE5MSnhXUVdDdFpjcHFrdy82NDA?x-oss-process=image/format,png\"></p><p><br></p><p>Next.js是全栈式的React框架，最初以Express为基础构建，但它此后从Express转换成了无服务器和静态优化，开始疯狂的发展。</p><p><br></p><p>将EricElliottJS.comExpress转换为无服务器的Next.js，托管费用将减少90%，还可以加快页面加载速度。强烈推荐。笔者目前在用Next.js和Zeit托管应用程序。</p><p><br></p><p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9qTmIwbXlnYjh4Q3J2bkxKbmFZeTFJaWFVZHhUT1lnZWtIUFY2d1p4a3gwOWliZDJMdFJQQmRQYks1blV6MVhIY05SZjNNbHN4MThOeDJJd1BPVUJxT2RBLzY0MA?x-oss-process=image/format,png\"></p><p><br></p><p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9QTFNBaHVFbEZ4bXl1ZjA0ckNGWE8walI5MGNTdnNUaWFkc1lmWVI0QjZMeUNCRXpnYTRJT1BpYkxEOUlORjNTdm16RThkdUQ0eFVDWXJZaHdHeGliSlA3dy82NDA?x-oss-process=image/format,png\"></p><h1><a></a><a></a><strong>测试</strong></h1><p><br></p><p>Jest和Cypress分别是最受欢迎的单元和功能测试工具，但是笔者更偏好RITEWay和TestCafe。RITEWay是单元测试的鼻祖：它是一种测试框架，始终回答每个单元测试必须回答的5个问题。</p><p><br></p><p>TestCafe是一种功能测试工具，像Cypress一样，它不需要用户与Selenium斗争，但有更好的跨浏览器支持和出色的测试记录器/IDE。强烈推荐质量评价团队使用TestCafe。</p><p><br></p><p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9QTFNBaHVFbEZ4bXl1ZjA0ckNGWE8walI5MGNTdnNUaWFkc1lmWVI0QjZMeUNCRXpnYTRJT1BpYkxEOUlORjNTdm16RThkdUQ0eFVDWXJZaHdHeGliSlA3dy82NDA?x-oss-process=image/format,png\"></p><h1><a></a><a></a><strong>功能工具</strong></h1><p><br></p><p>Lodash、Ramda、Immer、Redux和RxJS是笔者经常使用的功能工具。</p><p><br></p><p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9qTmIwbXlnYjh4Q3J2bkxKbmFZeTFJaWFVZHhUT1lnZWtpYzVqOUMxcTNlYjNIS1hFcWJIQkxTMDNIY042VlNxd2oxcVNSRmtYMDJsS2NzaWNYSmFpYWVUT3cvNjQw?x-oss-process=image/format,png\"></p><p><br></p><p>2019年，Ramda实现了长足发展，并提供了Lodash没有的一些工具，包括镜头和传感器。通过管道运算符，RxJS提供传感器样式功能。</p><p><br></p><p>Immer无需改变JavaScript对象，让操作变得容易。Redux是一种状态管理工具。</p><p><br></p><p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9QTFNBaHVFbEZ4bXl1ZjA0ckNGWE8walI5MGNTdnNUaWFkc1lmWVI0QjZMeUNCRXpnYTRJT1BpYkxEOUlORjNTdm16RThkdUQ0eFVDWXJZaHdHeGliSlA3dy82NDA?x-oss-process=image/format,png\"></p><h1><a></a><a></a><strong>2020年的科技格局</strong></h1><p><br></p><p>接下来的十年中，几种新兴技术将对人类生活产生巨大影响。以下是各方面技术的最新概况：</p><p><br></p><p>人工智能</p><p><br></p><p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9qTmIwbXlnYjh4Q2hpYjU2R0tWRkpKckdobTk5dEltdko5V1BXSVQxQ2tlTGU1bE9maWMwYlFPaWNzNjNJN2ljT0JiYWdZc2tKOGJXMFFSQThaQmtpYnBZaWFaUS82NDA?x-oss-process=image/format,png\"></p><p>来源：Pexels</p><p>人工智能可能是有史以来最具变革性的技术。各领域的学者和坚持己见的亿万富翁都将其描述为奇迹般的乌托邦或是人类的终结。</p><p><br></p><p>众所周知，人工智能或许真的是人类的终结，但也可能是人类与机器之间美好合作的开始。人类才刚刚开始模糊地了解人工智能未来的可能性。某些可能性令人恐惧（比如深度伪造），而某些可能性非常有用（比如Adobe Premiere用于视频编辑的全新自动重新构图）。到目前为止，事实是人工智能既令人恐惧又非常有用。人工智能将继续让一些可怕的事情发生，但通过人工智能改善人类生活的潜力又是巨大的。潘多拉的盒子已经打开，无法再关上，因此笔者希望人类能妥善运用人工智能解决重大问题并改善生活。</p><p><br></p><p>2019年，人工智能领域取得了许多重大突破。近年来，研究团队在多种电子游戏中就超人性能展开竞争，但某些级别的游戏对于人工智能来说仍充满挑战，包括《星际争霸Ⅱ》这样的长期战略性游戏。DeepMind的AlphaStar程序使用与人类玩家相同的资源，在官方的Battle.net服务器上进行游戏，已达到大师级水平。《星际争霸》是一款复杂的游戏，玩家需要具备长期的战略性思维，人们曾经认为人工智能尚不具备这种思维。具备战略性思维是人工智能通向通用人工智能道路上的一个重要里程碑。</p><p><br></p><p>如果这些游戏看起来像是对资源的愚蠢使用，那么请考虑一下DeepMind这样的项目，该项目在语音合成领域已取得重大进展，可为人工智能代理和私人助理提供更加自然的声音，另外，它还可让失声人士重新发声，这一点更加重要。</p><p><br></p><p>人工智能还可用于诊断癌症、预测蛋白质折叠（该过程可用于了解疾病、研发新药品）、恢复残疾人士对肢体的控制、生成逼真的图像等等。（来源）</p><p><br></p><p>自动驾驶汽车在变革性人工智能技术方面理应自成一派。该体系的主要参与公司包括Cruise、Uber、Waymo、Nuro、Aurora、Ford等等。该技术发展仍处于初级阶段，过分乐观已给该行业带来了大问题，但笔者深信不疑，超人的自动驾驶能力一定会在21世纪20年代出现。笔者曾在2015年对自动驾驶做过如下预测：</p><p><br></p><p>“到了2045年，开车的人看起来会像拉着越野车的马。”</p><p><br></p><p>5年以后，笔者认为自己低估了自动驾驶汽车上市的速度。2018年，Waymo的自动驾驶汽车行驶了超过一百万英里，美国有24个城市的公路上出现了自动驾驶汽车。现在，笔者预计到2025年，多家制造商的多种车型将实现5级全自主性。请密切关注特斯拉、通用、福特和宝马汽车公司。</p><p><br></p><p>过去的十年间，有关人工智能的研究论文出版量增长了10倍，目前人工智能正在为主流用户提供实际且有用的工具，预计该趋势在新十年间会持续下去。</p><p><br></p><p>人工智能做到了几年前大多数人认为不可能做到的事，这是有目共睹的。期待人工智能在21世纪20年代创造更大的奇迹。</p><p><br></p><p>区块链和加密货币</p><p><br></p><p>对于全球区块链和加密货币来说，2019年是具有里程碑意义的一年。区块链技术开始成为主流。预计2020年区块链会有更大的发展和主流采用。</p><p><br></p><p>DeFi的迅猛发展让用户友好、无许可以及无银行借贷成为可能。目前，DeFi拥有价值6.5亿美元的合同（包括4.5亿美元的无银行贷款），该技术于2019年投入使用。随着越来越多的人投资加密货币，笔者预计未来由加密技术支持的DeFi贷款会越来越多。</p><p><br></p><p>人们可以在不牺牲加密货币投资机会成本的前提下获得流动资产，或使用DeFi贷款通过杠杆效应（提高投资风险或回报）投资加密货币。</p><p><br></p><p>加密货币和区块链技术正在突破主流。比特币和以太坊的每日活跃地址数量于2018年1月达到峰值，随后一年因市场不景气，人们的兴趣开始减弱（加密货币价格每增长10倍就出现大幅回落，下一周期的峰值比前一周期的峰值高出10倍）。</p><p><br></p><p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9qTmIwbXlnYjh4Q3J2bkxKbmFZeTFJaWFVZHhUT1lnZWtsOTZrdTgySkFuUTdOYlhIbHVTOW5hZEltaWNINEd0MlB6aWNrd09FTFg5Y3JkT2R2ZVRBalRpY2cvNjQw?x-oss-process=image/format,png\"></p><p>比特币和以太坊区块链的每日活跃地址情况（来源）</p><p><br></p><p>l &nbsp;Square的Cash App安卓下载量超过一千万次——通过拥有极佳用户体验的应用软件，用户就可以购买、销售、发送和接收比特币。</p><p>l &nbsp;Coinbase的安卓下载量超过一千万次。</p><p>l &nbsp;Brave推出了内置的以太坊钱包，从十月到十一月底，该浏览器的月用户数量从870万上涨到了1040万。</p><p>l &nbsp;通过Sliver.tv和DLive，两千万电子游戏迷正在使用Theta网络进行分散式流媒体播放。</p><p><br></p><p>2019年，笔者最满意的进步是Fortmatic的引入。无论是否构建加密应用软件，都可以用Fortmatic代替用户身份验证，提高安全性，摆脱供应商锁定，添加端到端加密、签署交易等功能。</p><p><br></p><p>若要在2020年构建新应用程序，那么请考虑用Fortmatic代替滚动用户名/密码身份验证（2020年没人会这样做），或者将身份验证委托给谷歌、脸书等等。</p><p><br></p><p>笔者写过一篇文章，讨论了怎样利用加密技术改善应用程序身份验证并提高安全性。期待主流应用程序能在2020年采用Fortmatic这样的技术。</p><p><br></p><p>以太坊在2019年的智能合约平台竞争中轻松取胜。预计2020年它会继续占据主导地位。</p><p><br></p><p>增强现实</p><p><br></p><p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9qTmIwbXlnYjh4Q3J2bkxKbmFZeTFJaWFVZHhUT1lnZWtxUGZObEc2a2liOE5JOHNCVkR4bEZNeG4xWkJaQ1pUOW9MQ1QwbXZlbEZ2R0hYbjNhdldjOTdBLzY0MA?x-oss-process=image/format,png\"></p><p>来源：Pexels</p><p>笔者从小就梦想着增强现实能实现，自2015年以来，每年都在写关于它的承诺。扩展现实未来会取代手机。这只是时间问题。需要多长时间仍是个未知数，但目前看来，转变可能会在未来的十年间出现。甚至可能在未来的5年内出现。</p><p>虚拟现实和增强现实之间的界限已经模糊，因此业界现在将整个领域称为扩展现实。自问世以来，ARKit和ARCore（苹果和谷歌的增强现实软件开发工具包）已取得了很大发展。2017年至2019年5月，月活跃用户数量从4700万上涨到了1.5亿。</p><p><br></p><p>WebAR于2019年站稳脚跟，2020年可能会继续发展。若对此感兴趣，请查看AR.js、React 360或Viro React。</p><p><br></p><p>硬件方面取得了众多进展。2016年，开发者版本首次问世时，Hololens1售价约为5千美元。之后发生了什么呢？</p><p><br></p><p>Hololens2售价仍为3500美元，还未做好问世准备。剪辑、SLAM（抖动和偏移）、视野等方面仍存在问题。人们并不希望这些问题一直存在。但是每月99美元的定价让获得开发者工具包成为可能——即使需要等上一会儿。</p><p><br></p><p>无人机</p><p><br></p><p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9qTmIwbXlnYjh4Q3J2bkxKbmFZeTFJaWFVZHhUT1lnZWs0U0tJVlhlRmljU0VIOElZbk5tdjRnWTBuSXdZcndUN05jMTVTTmphOGVnaWI3VHZDaWNCRlN1R1EvNjQw?x-oss-process=image/format,png\"></p><p>来源：Pexels</p><p>美国已购买了约两百万架无人机，这些无人机已经改变了建筑、地理调查、绘图、影片、航拍、农业、环境科学和娱乐产业。2020年，商用无人机很有可能在美国实现交付。</p><p><br></p><p>FPV无人机比赛是笔者最喜欢的观赏性项目，无人机竞赛联盟现场直播比赛也是笔者的最爱。比赛还提供了精心设计的模拟器，以便观众了解无人机的样子。</p><p><br></p><p>所有新型无人机活动都需要许多软件，包括图像处理、无人机地图绘制软件、交付飞行计划、遥测记录与处理、分析、行业应用程序集成等等。</p><p><br></p><p>无人机软件也与人工智能有许多重叠之处——自动飞行的无人机需要图像处理、防碰撞等等。</p><p><br></p><p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9QTFNBaHVFbEZ4bXl1ZjA0ckNGWE8walI5MGNTdnNUaWFkc1lmWVI0QjZMeUNCRXpnYTRJT1BpYkxEOUlORjNTdm16RThkdUQ0eFVDWXJZaHdHeGliSlA3dy82NDA?x-oss-process=image/format,png\"></p><h1><a></a><a></a><strong>结语</strong></h1><p><br></p><p>21世纪的首个十年涌现了许多变革性技术，在人类看来，许多技术理所当然，但它们确实产生了重大影响：</p><p><br></p><p>l&nbsp; 照片墙 (Instagram)</p><p>l &nbsp;声田(Spotify)</p><p>l&nbsp; 优步(Uber)</p><p>l&nbsp; 虚拟助手</p><p>l&nbsp; 无线耳塞</p><p>l&nbsp; 主流虚拟现实</p><p>l&nbsp; 增强现实（用于热门游戏《口袋妖怪GO》）</p><p>l&nbsp; 价格实惠的特斯拉</p><p>l&nbsp; 共享经济（汽车、小轮摩托车、自行车）</p><p>l&nbsp; 主流平板电脑</p><p>l&nbsp; 主流生物识别技术（触摸识别、人脸识别）</p><p>l&nbsp; 众筹</p><p><br></p><p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9qTmIwbXlnYjh4QUh0Q2ljTUlWcnpKOWhRaWNsank1M2o2YXJTMzd2VjZoYkhhUnVhcmZnQVRDOUlKaWJmaWNXZGxWaWNIaWJVbzlLQ3UybFZmV2hLdWJlZmlhcVEvNjQw?x-oss-process=image/format,png\"></p><p>来源：Pexels</p><p>笔者迫不及待地想看看人类在新十年中的发展。</p><p><br></p><p>创造一些奇迹吧。</p><p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2dpZi9qTmIwbXlnYjh4Q3J2bkxKbmFZeTFJaWFVZHhUT1lnZWt3aWNvTzRkR1JBS1dQaGo4eVlUODFoWXBwY1RWTkkxWFJqZGlhN0VQN1FEV24wZ1hjR0F2cWtwUS82NDA?x-oss-process=image/format,png\"></p><p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9qTmIwbXlnYjh4Q2RpY21XYTlpY3kwczZ0Mkd5aWJVdDhZRWZnSGx2ekM4eTA5VlhQVVNIMWIwOGdnbW1oczVBNVlPMm5SY1ZpY2I4bU1GMjNnRG9XV1I4Z1EvNjQw?x-oss-process=image/format,png\"><br></p><p><strong><strong>推荐阅读专题</strong></strong></p><p><a href=\"https://mp.weixin.qq.com/s?__biz=MzI2NjkyNDQ3Mw%3D%3D&amp;chksm=ea87e689ddf06f9f8ab44dc4635325234621c0bbcf281a7a627823d174129ee2379673cd668f&amp;idx=1&amp;lang=zh_CN&amp;mid=2247491167&amp;scene=21&amp;sn=eae8fb36ab549481bfd3ef8ef3ee020b&amp;token=185130169#wechat_redirect\"><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9QTFNBaHVFbEZ4a0czZ0ExUVNleW1zeGduNVdpYmJSeHNOSGdVbmhOWkZDU3ZZdm4wM0s3TXRnV2xoYUJXU214Y29mamxNbmljZ1Bud2p0R0QwbGFiZGxnLzY0MA?x-oss-process=image/format,png\"></a></p><p><a href=\"https://mp.weixin.qq.com/s?__biz=MzI2NjkyNDQ3Mw%3D%3D&amp;chksm=ea87e689ddf06f9fe52da626f62ea53dfb10955bc6e1c4bb6254e105ca16028bc1dd3d1e43c4&amp;idx=4&amp;lang=zh_CN&amp;mid=2247491167&amp;scene=21&amp;sn=202e52389595c003f4619288697a24f5&amp;token=185130169#wechat_redirect\"><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9QTFNBaHVFbEZ4azV1aWJCSWpWWkR3MGhqY1ZQTVNtQU5Ld1RwOXJ0VzhSSVA5WjNPalpPV0x5cWxiTm1tSWRQdGNETWlhRzlHUzAxSUN6UmVMaWNYTElpYWcvNjQw?x-oss-process=image/format,png\"></a></p><p><a href=\"https://mp.weixin.qq.com/s?__biz=MzI2NjkyNDQ3Mw%3D%3D&amp;chksm=ea87e689ddf06f9fe8ab7cf037a4b8a3f99a567f324d792e8654b855985276fd684e3fc2b268&amp;idx=2&amp;lang=zh_CN&amp;mid=2247491167&amp;scene=21&amp;sn=e020c5080f9eb1ef60d056e8a00f5b7d&amp;token=185130169#wechat_redirect\"><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9QTFNBaHVFbEZ4bE9NdXV6UHFKcmlidkNQekNWWVV4VHRSMWljNVBpYnhKaWJXaWNlTm1DZDVNdm1pYzFWcHgzSWdyODFHUmlhbk9pYmFZcUN0N1FkaHl0eWhpYkNSZy82NDA?x-oss-process=image/format,png\"></a></p><p><a href=\"https://mp.weixin.qq.com/s?__biz=MzI2NjkyNDQ3Mw%3D%3D&amp;chksm=ea87e689ddf06f9f8ee5f974f7db8266803e8c69052bdc3c96651958d0989dbe62a10f2c5b29&amp;idx=3&amp;lang=zh_CN&amp;mid=2247491167&amp;scene=21&amp;sn=8f88373b1284ade3ca34deff77f83846&amp;token=185130169#wechat_redirect\"><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9QTFNBaHVFbEZ4blZ2QTBrSmdXbTVqR1JBbXhSYUw5amx4SmFDQnhvMTdjeDU3OXdWVWNPRUxlNEZrUGt4YXVQRGVCUHdSSWZMM2xLaWFhQ3VwNWZOaWNRLzY0MA?x-oss-process=image/format,png\"></a></p><p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9QTFNBaHVFbEZ4bXl1ZjA0ckNGWE8walI5MGNTdnNUaWFsZkNpY3duUGhoRExrajJKdmFNVHEzRHNaN25ZZ1gyNWxueGd2THh5WWhDMktMNmlheUJjUHpsdy82NDA?x-oss-process=image/format,png\"></p><p><strong><strong>留言点赞发个朋友圈</strong></strong></p><p><strong><strong>我们一起分享AI学习与发展的干货</strong></strong></p><p>编译组：周果、王馨</p><p>相关链接：</p><p>https://medium.com/javascript-scene/top-javascript-frameworks-and-topics-to-learn-in-2020-and-the-new-decade-ced6e9d812f9</p><p>如转载，请后台留言，遵守转载规范</p><p><strong><strong>推荐文章阅读</strong></strong></p><p><a href=\"https://mp.weixin.qq.com/s?__biz=MzI2NjkyNDQ3Mw%3D%3D&amp;chksm=ea87ee2addf0673cae27c598a097f5addad5d81b2ed766e570f20fc0fb12b77c5cf34098022e&amp;idx=1&amp;lang=zh_CN&amp;mid=2247489276&amp;scene=21&amp;sn=98e22e2b69478303f1f1a0a51e712570&amp;token=192322725#wechat_redirect\">ACL2018论文集50篇解读</a></p><p><a href=\"https://mp.weixin.qq.com/s?__biz=MzI2NjkyNDQ3Mw%3D%3D&amp;chksm=ea87eaadddf063bb3ab4ec5af616612a45f8d4fe9a5ad558f66278478296060253c1564bd05c&amp;idx=1&amp;lang=zh_CN&amp;mid=2247488123&amp;scene=21&amp;sn=a55185f3a693f7a5d85b1abe3dd36177&amp;token=140500370#wechat_redirect\">EMNLP2017论文集28篇论文解读</a></p><p><a href=\"https://mp.weixin.qq.com/s?__biz=MzI2NjkyNDQ3Mw%3D%3D&amp;chksm=ea87f6ebddf07ffd8e84bcc18d7122f894b6cf5dc967daad9c2e122edb22968fd6f589d6852f&amp;idx=1&amp;mid=2247487037&amp;scene=21&amp;sn=37cd38b305aa874c29d764361c88a202#wechat_redirect\">2018年AI三大顶会中国学术成果全链接</a></p><p><a href=\"https://mp.weixin.qq.com/s?__biz=MzI2NjkyNDQ3Mw%3D%3D&amp;chksm=ea87f59addf07c8c2480dd46784a431612d099d3d0531449aa8e64f68b3ba340363578d95659&amp;idx=1&amp;mid=2247486796&amp;scene=21&amp;sn=a8ae95efbf16985a259c4cd66bf919f2#wechat_redirect\">ACL2017论文集：34篇解读干货全在这里</a></p><p><a href=\"https://mp.weixin.qq.com/s?__biz=MzI2NjkyNDQ3Mw%3D%3D&amp;idx=1&amp;lang=zh_CN&amp;mid=2247487100&amp;scene=21&amp;sn=3bd640ec4f00c5104664687194dd9a51&amp;token=77118319#wechat_redirect\">10篇AAAI2017经典论文回顾</a></p><p><strong>长按识别二维码可添加关注</strong></p><p><strong>读芯君爱你</strong></p><p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2dpZi9RR2o3V0YzbFIwUnhhOU42aEo4eFFwdnNaR2ljR09LSXBpYWtCOXlQQjl3RlFvMWliYVB3ZU9qcDFkYndpYWUzdXg4OERXRWg1dExFcHo2S0pqemNVSDVwOWcvNjQw?x-oss-process=image/format,png\"></p>',0,'2020-12-14 15:19:18'),(9,'http://localhost:12345/static/uploadtextimg/timg.jpg','http://localhost:1234/static/uploadusertimg/timg.jpg','郝天恒1','html','关于HTML的文章',' <p>HTML<br>标题和水平线<br>&lt;h1&gt;标题&lt;/h1&gt;这个表示的是一级标题，&lt;h2&gt;&lt;h3&gt;&lt;h4&gt;&lt;h5&gt;&lt;h6&gt;依次表示的标题字符的依次递减<br><br>&lt;hr&gt;表示水平线，单独站一行<br><br>属性：align：center，left，right  表示元素在网页中的显示位置。<br><br>size：这可以表示下划线的厚度  单位px（像素）。<br><br>width：可以表示下划线的大小，80%，表示占据网页的80%。<br><br>段落和换行<br>&lt;p&gt;段落&lt;/p&gt; 段落与段落之间会有稍大一点的间隔<br><br>&lt;br/&gt;单标签，表示的换行，通常用在文章中代表在网页中另起一行。<br><br>图片<br>&lt;img src=\" 路径\" alt=\"图片加载失败显示的内容\"  /&gt;<br><br>img标签表示的是对图片的引用，向网页中嵌入一幅图片。我们可以使用属性来对图片进行调整大小，边框等。<br><br><br><br><br><br>超链接<br>&lt;a href=\"超链接\"&gt;内容&lt;a/&gt;  超链接标签，用于链接另外一个页面。若是href属性中没有内容，则a标签内的内容和普通文本没有区别<br><br>也可以在本页面内跳转，但是需要元素的唯一标识，通常使用id进行跳转，直接在 &lt;img src=\"\" id=\"id1\"&gt;&lt;a id=\"#id1\"&gt;来跳转<br><br><br><br>div和span<br>&lt;div&gt;是一个块级元素，通常与 css配合使用，用于布局。<br><br>&lt;div&gt; 标签可以把文档分割为独立的、不同的部分。它可以用作严格的组织工具，并且不 使用任何格式与其关联。<br><br>&lt;div&gt; 是一个块级元素。这意味着它的内容自动地开始一个新行。实际上，换行是 &lt;div&gt; 固有的唯一格式表现。可以通过 &lt;div&gt; 的 class 或 id 应用额外的样式。<br><br>标签的分类<br>HTML中标签元素三种不同类型：块状元素，行内元素，行内块状元素。<br><br>块级元素特点： 元素都从新的一行开始，并且其后的元素也另起一行；元素的高度、宽度、 行高以及顶和底边距都可设置；元素宽度在不设置的情况下，是它本身父容器的 100%（和父 元素的宽度一致），除非设定一个宽度。<br><br>行内元素特点 ：和其他元素都在一行上；元素的高度、宽度及顶部和底部边距不可设置； 元素的宽度就是它包含的文字或图片的宽度，不可改变<br><br>行内块状元素的特点：和其他元素都在一行上；元素的高度、宽度、行高以及顶和底边距 都可设置<br><br>表格<br>使用&lt;table&gt;&lt;/table&gt;标签，一行使用&lt;tr&gt;&lt;/tr&gt;来表示，每行的每个单元格使用&lt;td&gt;&lt;/td&gt;<br><br>如果想要合并单元格，如果想要行合并，使用rowspan属性进行跨行（列）合并，colspan属性则是用来表示跨列（行）合并<br><br>列表<br>&lt;ul&gt;&lt;li&gt;&lt;/li&gt;&lt;/ul&gt;表示一个列表的每一行，但是这是无序了，也就是说这个没列的前面并没有数字这一选项。<br><br>&lt;ol&gt;则是可以在每列的前面使用数字表明，有序列的排序。<br><br><br><br>表单<br>表单可以使用&lt;form&gt;来进行创建，它可以向服务器穿数据，它是一个块级元素。<br><br><br><br>在表单内可以使用&lt;input&gt;来搜集用户的数据 ，这是一个单标签，可以使用type属性来标明这个input的元素输入字段，输入字段可以是文本字段、复选框、 掩码后的文本控件、单选按钮、按钮等等。<br><br></p>',0,'2020-12-14 15:58:18'),(10,'http://localhost:12345/static/uploadtextimg/timg.jpg','http://localhost:1234/static/uploadusertimg/timg.jpg','郝天恒2','综合','浅谈web前端开发',' <p>有部分同学和朋友问到过我相关问题，利用周末我就浅浅地谈谈我对web前端开发的理解和体会，只能浅浅谈谈，高手请自动跳过本篇文章。毕竟我现在经验并不是很足，连工程师都算不上，更不用说大牛了。今天也不谈技术，技术很多人比我掌握得更好，也大同小异，但是每个人的理解体会是不一样的。</p><h2><a></a><a></a>对前端开发的三个总体理解和体会</h2><p>我对前端开发的总体体会有三：</p><p>第一：杂而难，难度甚至超过了一般的后台开发，如果有人觉得前端开发简单只能说明他还没有入门。</p><p>第二：web前端开发正在向响应式和移动端方向大步迈进。</p><p>第三：前端工程师其实就是编程技术人员，用一句话来形容“<strong>比UI设计懂技术，比技术人员更懂交互</strong>”，当然也有人说前端工程师是工程师中的设计师，是设计师中的工程师。既然是编程工作，那就不会做一辈子，毕竟太累。认真敲几年代码然后去卖水果吧，还望师弟师妹们来照顾我生意。<br></p><h2><a></a><a></a>网页制作与web前端开发</h2><p>前端开发工程师是一个比较新的职业，在国内乃至国际上开始受到重视的时间不超过几年。互联网进入2.0时代后，web开发技术得到了空前的发展，尤其是前端技术。近几年，随着用户对体验的要求越来越高，前端开发技术难度也越来越大。曾经设计和制作不分的职位也终于分为UI设计师和web前端开发工程师（前端开发师）两个职位，<strong>分别向艺术和技术的方向纵向发展</strong>。</p><p>从技术体系上讲，前端开发师需要掌握和了解的东西非常多，有些大牛用庞杂来形容。</p><p>几年前，还没有前端开发的时候我们叫做网页制作，主要内容都是静态的页面，用户也是以浏览为主，而现在发生了翻天覆地的变化，网页不再只是承载单一的文字和图片，各种富媒体让页面内容更加生动，更注重用户体验。</p><p>以前会平面设计软件、DW和简单的HTML、CSS、JS就可以制作网页，现在只掌握这些已经远远不够了，如果只掌握这些连工作机会都很少。无论是开发难度，还是开发方式，现在的web前端开发都接近传统的网站后台开发，我觉得比一般的后台开发更复杂。一个网站或者移动应用是否专业、功能是否强大。服务器端是用J2EE+Oracle组合还是ASP+Access组合，并没有太明显的区别，但是，前端的用户体验却给了用户直观的印象。所以现在不仅仅是网页制作，而是web前端开发。大部分人认为是web前端开发取代了以前的网页制作，我认为现在网页制作和web前端开发的岗位同时存在。如果仅仅掌握以前网页制作的技术，那么现在还是叫网页制作师（我在招聘网页上也看到不少网页制作师这个岗位），并不能称之为web前端工程师。</p><p><br></p><h2><a></a><a></a><strong>Web前端开发一般要掌握哪些技术和具备哪些条件？</strong></h2><p><br></p><p><strong>第一、要掌握曾经网页制作师掌握的基本技术。</strong>如各种页面布局，面向对象编程，JS模块化编程，设计模式，前端MVC等等。</p><p><strong>第二、网站性能优化，SEO。</strong>如尽量减少HTTP请求次数、cssSprites图片整合技术、合并css与js、运用CDN技术。减少DNS查找次数、避免重定向等。</p><p><strong>第三、要会UI设计。</strong>当然在一些相对较小的公司前端工程师也担任着UI设计的角色。在大公司虽然有专业的UI设计师，但是前端工程师会UI设计能帮助你更准确的理解设计师的意图，在原型不完整的时候也能正确的反馈设计缺陷，将问题阻挡在设计的环节，会大大减少UI bug数量，比如，设计师会给出理想状态下的容器样式，却往往忽略了文字溢出折行、长连续字符、容器宽高是否适应内容尺寸变化而变化，溢出部分是作截字还是隐藏等诸多细节，因为设计师不一定懂“边界值测试”的道理，而这些问题往往在测试阶段才被发现，所以，如果能在拿到UI设计稿时就提醒设计师补充完整这些场景，自然减少测试回归次数。</p><p><strong>第四、至少要会一门后台编程语言。</strong>职业的特殊性决定了我们需要跟后端工作者频繁的沟通。如果只顾页面实现，不考虑后台，写出来的页面也有一部分是废弃代码，在后台进行数据交互的时候用不了。还有一方面就是从招聘信息可以得知，现在几乎所有公司前端开发岗位都明确要求会后台语言，在实际工作中可能也要做客户端和服务器端之间的数据交互等。</p><p><img src=\"https://img-blog.csdn.net/20151219122844646\" alt=\"\"><br></p><p><strong>第五、掌握各种浏览器兼容解决办法。</strong>国内和国际主流浏览器种类多，内核不统一，如以Trident为内核的IE、以Gecko为内核的FireFox、以Presto为内核的Opera、以Webkit为内核的google chrome和Safari等，这给我们前端开发增加了很多困难，也是大多数人头疼的事情，且不说目前市面在有这么多的浏览器，就仅仅单一的IE系列家族的问题也够多的了，特别是IE6，IE7。下图是本月对上个月全球浏览器市场统计排行，IE浏览器用户任然超过百分之五十。尽管2016年1月起，微软将停止对旧版IE浏览器的支持。<a target=\"_blank\" href=\"http://news.softpedia.com/news/microsoft-will-start-nagging-windows-7-users-to-update-their-browsers-497698.shtml\">【微软相关原新闻链接请猛击这里】</a>但是我相信最近很多年之内IE低版本浏览器还是会占比较大的比例，消亡还需时日。</p><p><img src=\"https://img-blog.csdn.net/20151219120829374\" alt=\"\"><br></p><p><br></p><p><strong>第六、必须学会运用各种工具进行辅助开发。</strong></p><p><strong>第七、除了掌握技术层面的知识，还有掌握理论层面的知识。</strong>包括渲染原理，代码的可维护性，组件的易用性，分层语义模板等等。</p><p><strong>第八、要有细心和耐心。</strong>和UI设计一样，我们必须精确到每一个像素，耐心也体现在多方面，比如让初期开发者头疼的兼容问题，如果编码不够规范，解决兼容问题的时间远远超过了页面实现的时间。</p><p><strong>第九、热爱并不断学习新技术。</strong>前端几乎每天都有新技术产生，从事这一行，在打牢基础的情况下要不断学习新技术。包括开发流程部署，预处理技术，前端框架(如RequireJS、ReactJS、AngularJS等等)，移动终端，标准规范等。</p><p><br></p><h2><a></a><a></a><strong>浅谈自己的体会</strong></h2><p><br></p><p><strong>与服务器端语言先慢后快的学习曲线相比，前端开发的学习曲线是先快后慢。</strong>所以现在有很多学生或者已从事工作了的人都开始想涌入web前端开发的潮流，并自学成“才”，但我知道大多数人都停留在会用的阶段，因为要想成为一名真正的web前端开发师每前进一步都很难。尽管有的人每天都利用工作之余学习，却还是学不精，于是处于纠结迷茫的状态。另一方面，正如开篇所说，这还是一个比较新的职业，对一些规范和最佳实践的研究都处于探索阶段，一些新的技术随时都会闪现出来，例如：浏览器大战也越来越白热化，跨浏览器兼容方案依然五花八门，目前我所在的公司一般要求我们兼容到IE7，以前经常遇到这种情况，好不容易把IE各个版本都兼容了，高兴之余又发现在360浏览器上出现了bug，没办法，熬夜奋战呗。</p><p>前端开发工程师是一个易学难精的职业，我们必须深入、系统地学习并掌握前端知识，如果简单地自学一下就能成为web前端工程师，那我想现在市场上也不会出现高薪找不到前端工程师的情况了。有经验的web前端开发工程师都知道，要精通这一行，必须先精通十行。有一些有经验的前端工程师，在不断寻求新的技能上的突破，最明显的一点体现是，开始关注“底层协议”，即HTTP、第三方应用、系统对接、制造工具、工作流程等，这时思考的重点已经脱离了“切页面”，变为“出方案“，比如要架设一个站点，能够搭建站点框架，预见站点后续（前端）开发中的所有风险，并一一给出解决方案。</p><p>说说半路出家的危与机，俗话说，隔行入隔山。每个行业自有其道，自然不是想做就做。前端技术领域半路出家者非常多，我们来分析一下转行的心理。第一，看到前端技术入门简单、互联网对前端技术的需求缺口大；第二，前端技术所见即所得、感觉学习起来很快；第三，我身边的某某转行作前端看上去不错、我似乎也可以；第四，我不喜欢我现在做的工作、想换行业、正好前端技术上手较快，就选他吧；当然还有第五，我的确了解并喜欢做Web前端，为它付出再多都是值得的。</p><p>新进入这一行或者转行者的心态比较容易走两个极端，<strong>一是只看到新行业的好，二是只觉得原工作很糟糕</strong>。但不管是什么行业，对自己的职业规划的思考都应当先行一步。进入这一行必须先清晰的回答这些问题：</p><p>1.我能做什么？</p><p>2.我不能做什么？</p><p>3.我的优势是什么？</p><p>4.我的劣势是什么？</p><p>5.做这一行对我有何好处？</p><p>6.做这一行会让我付出何种代价？</p><p>7.如何定义成功？</p><p>因为面试的时候一定会被这些问题所挑战。如果支支吾吾说不清楚，要么是对自己未来不负责任，要么骨子里就是草根一族，习惯做什么都蜻蜓点水浅尝辄止，也难让人信服你进入这一行是一个权衡再三看起来合理的选择。</p><p><br></p><h2><a></a><a></a><strong>相关误区解释</strong></h2><p><br></p><p>有人认为前端工程师上班不干别的，就是玩，弄点效果，攒两页面，搞点创新。当然这个表述非常轻巧、甚至有调侃的味道，web前端工作绝对不是玩那么简单的，更不像曾经的网页制作那么单一，有时候会为一些效果的实现或优化，弄得加班加点。上周还因为解决一个问题花了2天的时间，惭愧啊。所以前端开发是一项很特殊的工作，前端工程师的工作说得轻松，看似轻巧，但做起来绝对不是那么的简单。在开发过程中涵盖的东西非常宽广，既要从技术的角度来思考界面的实现，规避技术的死角，又要从用户的角度来思考，怎样才能更好地接受技术呈现的枯燥的数据，更好的呈现信息。</p><p>在入行初期，很多人过于着迷，从而陷入了迷途。比如有人纠结于是否将dt、dd的样式清除从reset.css中拿掉，原因是觉得这两个标签的清除样式会耗费一些渲染性能；或者是否需要将for循环改为while循环以提高js执行速度。尽管这些考虑看上去是合理的，但并不是性能的瓶颈所在，也就是说，你花了很大力气重构的代码带来的页面性能提升，往往还不如将两个css文件合成一个带来的提升明显。就好比用一把米尺量东西，没必要精确到小数点后10位，因为精确到小数点后2位就已经是不准确的了。这种技术误区常常让人捡了芝麻丢了西瓜。</p><p><br></p><h2><a></a><a></a><strong>对自己学习和工作的要求</strong></h2><p><br></p><p>N.C.Zakas曾经勉励过大家，现在成为了我对自己的要求和对已结确定要走Web前端开发方向的人的建议：热爱你的工作。热爱跨浏览器开发带来的挑战、热爱互联网技术的种种异端，热爱业内的同行，热爱你的工具。互联网发展太快了，如果你不热爱它的话，不可能跟上它的步伐。这意味着你必须多阅读，多动手，保证自己的才能与日俱增。要为如何编写易于维护、高质量的前端代码奋斗。下了班也不能闲着，要做一些对自己有用的事儿。可以参与一些开源软件的开发，读读好书，看看牛人的博客。经常参加一些会议，看看别人都在干什么。要想让自己快速成长，有很多事儿可以去做，相信付出一定会有回报。</p><p><br></p><p><br></p><p>这次就分享到这里，一个上午就这样过去了，饿了，该去做中午饭了。关于前端开发具体相关技术和具体怎么学习发展下次我会继续分享。</p><p>最后，因时间仓促，资质有限，文中表述仅代表个人观点，不准确的地方还望见谅，欢迎严厉地指正。</p><p><br></p><p><img src=\"https://img-blog.csdn.net/20151219121405199?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"></p>',0,'2020-12-14 15:59:22'),(12,'http://localhost:12345/static/uploadtextimg/timg.jpg','http://localhost:1234/static/uploadusertimg/timg.jpg','郝天恒','react','React.js学习笔记之组件属性与状态',' <h2>React.js学习笔记之组件属性与状态</h2><p>@(前端技术)</p><blockquote><p>组件本质上是状态机，输入确定，输出一定确定</p></blockquote><p>组件把状态与结果一一对应起来，组件中有state与prop（状态与属性）。</p><ul><li><p>属性是由父组件传递给子组件的</p></li><li><p>状态是子组件内部维护的数据，当状态发生变化的同时，组件也会进行更新。当状态发生转换时会触发不同的钩子函数，从而让开发者有机会做出相应.</p></li></ul><h3>statics</h3><p>statics 对象允许你定义静态的方法，这些静态的方法可以在组件类上调用。</p><pre><code>varMyComponent = React.createClass({statics: {customMethod:function(foo){returnfoo ===\'bar\';\n    }\n  },render:function(){\n  }\n});\n\nMyComponent.customMethod(\'bar\');// true</code></pre><p>在这个块儿里面定义的方法都是静态的，意味着你可以在任何组件实例创建之前调用它们，这些方法不能获取组件的 props 和 state。如果你想在静态方法中检查 props 的值，在调用处把 props 作为参数传入到静态方法。</p><h3>props</h3><p>this.props 表示一旦定义，就不再改变的特性</p><h4>属性的用法</h4><h5>1.键值对</h5><p><code>键 ：值</code><br>值可以有多种形式<br><code>&lt;HelloWorld name= ? /&gt;</code></p><ul><li><p>字符串：\"XiaoWang\"</p></li><li><p>求值表达式 {123}、{\"XiaoWang\"}</p></li><li><p>数组{[1,2,3]}</p></li><li><p>变量{variable}</p></li><li><p>函数求值表达式{function}（不推荐，如果需要函数可以单独把函数提取出来然后单独调用函数）</p></li></ul><pre><code>varHelloWorld =React.createClass({rencer:function(){return&lt;p&gt;Hello,{this.props.name ? this.props.name : \"World\"}&lt;/p&gt;;\n    },\n});varHelloUniverse = React.createClass({getInitialState:function(){return{name:\'\'};\n    },handleChange:function(event){this.setState({name: event.target.value});\n    },render:function(){return&lt;div&gt;&lt;HelloWorldname={this.state.name}&gt;&lt;/HelloWorld&gt;&lt;br/&gt;&lt;inputtype=\"text\"onChange={this.handleChange}/&gt;&lt;/div&gt;},\n});\nReactDom.render(&lt;HelloUniverse/&gt;,document.body);</code></pre><h5>2.展开语法{...props}</h5><p>React会自动把对象中的属性和值当做属性的赋值</p><pre><code>varHelloWorld =React.createClass({rencer:function(){return&lt;p&gt;Hello,{this.props.name1 + \' \'this.props.name2}&lt;/p&gt;;\n    },\n});varHelloUniverse = React.createClass({getInitialState:function(){return{name1:\'Tim\',name2:\'John\',\n        };\n    },handleChange:function(event){this.setState({name: event.target.value});\n    },render:function(){return&lt;div&gt;&lt;HelloWorldname={...this.state}&gt;&lt;/HelloWorld&gt;&lt;br/&gt;&lt;inputtype=\"text\"onChange={this.handleChange}/&gt;&lt;/div&gt;},\n});\nReactDom.render(&lt;HelloUniverse/&gt;,document.body);</code></pre><h5>3.setProps</h5><pre><code>varHelloWorld =React.createClass({rencer:function(){return&lt;p&gt;Hello,{this.props.name ? this.props.name : \"World\"}&lt;/p&gt;;\n    },\n});varinstance = React.render(&lt;HelloWorld/&gt;,document.body);\ninstance.setProps({name:\'Tim\'});</code></pre><p><code>setProps(object nextProps[, function callback])</code><br>可以设置组件的属性。这个方法已经过时了（与replaceProps等一样），不久将被删除。这个方法不支持ES6类组件React.Component扩展。</p><h4>propTypes</h4><p>组件的属性可以接受任意值，字符串、对象、函数等等都可以。有时，我们需要一种机制，验证别人使用组件时，提供的参数是否符合要求。</p><ul><li><p>组件类的PropTypes属性，就是用来验证组件实例的属性是否符合要求</p></li></ul><pre><code>varMyTitle = React.createClass({propTypes: {title: React.PropTypes.string.isRequired,\n  },render:function(){return&lt;h1&gt;{this.props.title}&lt;/h1&gt;;\n   }\n});</code></pre><p>上面的Mytitle组件有一个title属性。PropTypes 告诉 React，这个 title 属性是必须的，而且它的值必须是字符串。现在，我们设置 title 属性的值是一个数值。</p><pre><code>vardata =123;\nReactDOM.render(&lt;MyTitletitle={data}/&gt;,document.body\n);</code></pre><p>这样一来，title属性就通不过验证了。控制台会显示一行错误信息</p><h4>getDefaultProps</h4><p>getDefaultProps 方法可以用来设置组件属性的默认值。</p><pre><code>varMyTitle = React.createClass({getDefaultProps:function(){return{title:\'Hello World\'};\n  },render:function(){return&lt;h1&gt;{this.props.title}&lt;/h1&gt;;\n   }\n});\nReactDOM.render(&lt;MyTitle/&gt;,document.body);</code></pre><h4>this.props.children</h4><p>this.props 对象的属性与组件的属性一一对应，但是有一个例外，就是 this.props.children 属性。它表示组件的所有子节点</p><pre><code>varNotesList = React.createClass({render:function(){return(&lt;ol&gt;{\n        React.Children.map(this.props.children, function (child) {\n          return&lt;li&gt;{child}&lt;/li&gt;;\n        })\n      }&lt;/ol&gt;);\n  }\n});\nReactDOM.render(&lt;NotesList&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;world&lt;/span&gt;&lt;/NotesList&gt;,document.body\n);</code></pre><p>上面代码的 NoteList 组件有两个 span 子节点，它们都可以通过 this.props.children 读取。<br>这里需要注意， this.props.children 的值有三种可能：</p><ol><li><p>如果当前组件没有子节点，它就是 undefined；</p></li><li><p>如果有一个子节点，数据类型是 object；</p></li><li><p>如果有多个子节点，数据类型就是 array</p></li></ol><p>React 提供一个工具方法 React.Children 来处理 this.props.children 。我们可以用 React.Children.map 来遍历子节点，而不用担心 this.props.children 的数据类型是 undefined 还是 object。<br>1.React.Children.map<br><code>object React.Children.map(object children, function fn [, object context])</code><br>在每一个直接子级（包含在 children 参数中的）上调用 fn 函数，此函数中的 this 指向 上下文。如果 children 是一个内嵌的对象或者数组，它将被遍历：不会传入容器对象到 fn 中。如果 children 参数是 null 或者 undefined，那么返回 null 或者 undefined 而不是一个空对象。<br>2.React.Children.forEach<br><code>React.Children.forEach(object children, function fn [, object context])</code><br>类似于 React.Children.map()，但是不返回对象。<br>3.React.Children.count<br><code>number React.Children.count(object children)</code><br>返回 children 当中的组件总数，和传递给 map 或者 forEach 的回调函数的调用次数一致。<br>4.React.Children.only<br><code>object React.Children.only(object children)</code><br>返回 children 中仅有的子级。否则抛出异常。</p><h3>state</h3><blockquote><p>组件在运行时需要修改的数据就是状态</p></blockquote><p>组件免不了要与用户互动，React 的一大创新，就是将组件看成是一个状态机，一开始有一个初始状态，然后用户互动，导致状态变化，从而触发重新渲染 UI</p><blockquote><p>this.state 是会随着用户互动而产生变化的特性。</p></blockquote><h4>state工作原理</h4><p>常用的通知 React 数据变化的方法是调用 setState(data, callback)。这个方法会合并（merge） data 到 this.state，并重新渲染组件。渲染完成后，调用可选的 callback 回调。大部分情况下不需要提供 callback，因为 React 会负责把界面更新到最新状态。</p><pre><code>varLikeButton = React.createClass({getInitialState:function(){return{liked:false};\n  },handleClick:function(event){this.setState({liked: !this.state.liked});\n  },render:function(){vartext =this.state.liked ?\'like\':\'haven\\\'t liked\';return(&lt;ponClick={this.handleClick}&gt;You {text} this. Click to toggle.&lt;/p&gt;);\n  }\n});\n\nReactDOM.render(&lt;LikeButton/&gt;,document.getElementById(\'example\')\n);</code></pre><h5>getInitialState</h5><p><code>object getInitialState()</code><br>getInitialState 方法用于定义初始状态，也就是一个对象，这个对象可以通过 this.state 属性读取。在组件挂载之前调用一次。返回值将会作为 this.state 的初始值。</p><h5>setState</h5><p><code>setState(object nextState[, function callback])</code><br>合并 nextState 和当前 state。这是在事件处理函数中和请求回调函数中触发 UI 更新的主要方法。另外，也支持可选的回调函数，该函数在 setState 执行完毕并且组件重新渲染完成之后调用。this.setState 方法用于修改状态值，每次修改以后，自动调用 this.render 方法，再次渲染组件。</p><blockquote><p>注意：</p><ol><li><p>绝对不要直接改变 this.state，因为在之后调用 setState() 可能会替换掉你做的更改。把 this.state 当做不可变的。</p></li><li><p>setState ( ) 不会立刻改变 this.state，而是创建一个即将处理的 state 转变。在调用该方法之后获取 this.state 的值可能会得到现有的值，而不是最新设置的值。</p></li><li><p>不保证 setState ( ) 调用的同步性，为了提升性能，可能会批量执行 state 转变和 DOM 渲染。</p></li><li><p>setState ( ) 将总是触发一次重绘，除非在 shouldComponentUpdate ( ) 中实现了条件渲染逻辑。如果使用可变的对象，但是又不能在shouldComponentUpdate ( ) 中实现这种逻辑，仅在新 state 和之前的 state 存在差异的时候调用 setState ( ) 可以避免不必要的重新渲染。</p></li></ol></blockquote><h5>replaceState</h5><p><code>replaceState(object nextState[, function callback])</code><br>类似于 setState()，但是删除之前所有已存在的 state 键，这些键都不在 nextState 中。</p><blockquote><p>注意：这个方法在ES6类组件扩展不可用，它可能会在未来某个React版本中删除</p></blockquote><h4>哪些组件应该有 State？</h4><p>大部分组件的工作应该是从 props 里取数据并渲染出来。但是，有时需要对用户输入、服务器请求或者时间变化等作出响应，这时才需要使用 State。<br>尝试把尽可能多的组件无状态化。这样做能隔离 state，把它放到最合理的地方，也能减少冗余，同时易于解释程序运作过程。</p><blockquote><p>常用的模式是创建多个只负责渲染数据的无状态（stateless）组件，在它们的上层创建一个有状态（stateful）组件并把它的状态通过 props 传给子级。这个有状态的组件封装了所有用户的交互逻辑，而这些无状态组件则负责声明式地渲染数据。</p></blockquote><h4>哪些应该作为 State？</h4><p>State 应该包括那些可能被组件的事件处理器改变并触发用户界面更新的数据。 真实的应用中这种数据一般都很小且能被 JSON 序列化。当创建一个状态化的组件时，想象一下表示它的状态最少需要哪些数据，并只把这些数据存入 this.state。在 render() 里再根据 state 来计算你需要的其它数据。你会发现以这种方式思考和开发程序最终往往是正确的，因为如果在 state 里添加冗余数据或计算所得数据，需要你经常手动保持数据同步，不能让 React 来帮你处理。</p><h4>哪些不应该作为 State？</h4><p>this.state 应该仅包括能表示用户界面状态所需的最少数据。因此，它不应该包括：</p><ul><li><p>计算所得数据： 不要担心根据 state 来预先计算数据 —— 把所有的计算都放到 render() 里更容易保证用户界面和数据的一致性。例如，在 state 里有一个数组（listItems），我们要把数组长度渲染成字符串， 直接在 render() 里使用 this.state.listItems.length + \' list items\' 比把它放到 state 里好的多。</p></li><li><p>React 组件： 在 render() 里使用当前 props 和 state 来创建它。</p></li><li><p>基于 props 的重复数据： 尽可能使用 props 来作为惟一数据来源。把 props 保存到 state 的一个有效的场景是需要知道它以前值的时候，因为未来的 props 可能会变化。</p></li></ul><h3>属性和状态的对比</h3><h4>相似点</h4><h5>1. 都是纯JS对象</h5><p>纯JS对象就是JS中的原生对象。是使用 { } 来创建的对象</p><h5>2. 都会触发render更新</h5><p>状态和属性的变化都会触发render更新，属性和状态的改变都会触发整个生命周期流程，从处理属性到是否应该更新，到进行对比，到最后的render真正执行，会触发很多函数，我们可以在不同的函数中进行不同的对应操作。</p><h5>3. 都具有确定性</h5><p>给定相同的属性和相同的状态，组件生成的都是相同的代码</p><h4>对比</h4><table><thead><tr><th>Item</th><th>属性</th><th>状态</th></tr></thead><tbody><tr><td>能否从父组件获取初始值？</td><td>o</td><td>x</td></tr><tr><td>能否由父组件修改？</td><td>o</td><td>x</td></tr><tr><td>能否在组件内部设置默认值？</td><td>o</td><td>o</td></tr><tr><td>能否在组件内部修改？</td><td>x</td><td>o</td></tr><tr><td>能否设置子组件的初始值？</td><td>o</td><td>x</td></tr><tr><td>能否修改子组件的值？</td><td>o</td><td>x</td></tr></tbody></table><ul><li><p>状态只与组件本身相关，由自己本身维护。与父组件与子组件无关</p></li><li><p>组件不能修改自己的属性，但可以从父组件获取属性，父组件也能修改其属性，组件也可以修改子组件的属性</p></li></ul><h3>实例</h3><p>关于属性与状态的实例代码传送门：<a href=\"https://github.com/Xiaoxianrou/Blog/tree/master/2016.02/React-Demo/demo1\" target=\"_blank\">React简易小demo</a></p><h3>小结</h3><p>本文主要介绍了组件的属性与状态。组件化是React的主要思想，也是其核心所在。组件化也是前端未来的发展趋势，React算是引领了这一潮流吧。关于属性与状态的更多用法在生命周期与协同使用中还会介绍。</p><h4>PS</h4><p>被官微转发了有点小意外。声明下，目前在网上找不到一个比较完整的文字react学习文章，博主决定利用业余时间总结下。本博文原创内容不多，大部分都是对文档与网上文章的自己学习总结。</p><h4>特别感谢</h4><ul><li><p><a href=\"http://www.jikexueyuan.com/course/reactjs/\" target=\"_blank\">极客学院React.js系列课程</a></p></li><li><p><a href=\"http://www.ruanyifeng.com/blog/2015/03/react.html\" target=\"_blank\">React 入门实例教程 by 阮一峰</a></p></li><li><p><a href=\"http://facebook.github.io/react/index.html\" target=\"_blank\">React.js官方文档</a></p></li></ul>',0,'2020-12-14 16:02:43'),(13,'http://localhost:12345/static/uploadtextimg/timg.jpg','http://localhost:1234/static/uploadusertimg/timg.jpg','郝天恒1','react','关于React总结',' <h2><p><img src=\"https://img-blog.csdnimg.cn/20200106204502543.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1dlbmR5bXd6,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p></h2><h2><a></a><a></a><a></a>一 ：React 介绍</h2><h4><a></a>1.1：什么是react</h4><h2><blockquote><p>react是用来构建用户界面的JavaScript库，vc很多人认为是react是MVC中的v（视图）。</p></blockquote></h2><h4><a></a>1.2：React 的特点</h4><h2><blockquote><ol><li>高效</li><li>灵活</li><li>Jsx</li><li>单项数据流</li><li>声明范式编写方式</li><li>组件化开发</li></ol></blockquote></h2><h4><a></a>1.3：React 的优点</h4><h2><blockquote><ol><li>它提高了应用的性能 可以方便地在客户端和服务器端使用 由于 JSX，代码的可读性很好 React很容易与 Meteor，Angular 等其他框架集成 使用React，编写UI测试用例变得非常容易。</li><li>React组件化开发，使用ES6的语法来自定义复杂的标签（组件），很多实现某些功能的自定义组装在一起，就可以完成更复杂的UI界面</li></ol></blockquote></h2><h2><a></a><a></a><a></a>二：es6</h2><h4><a></a>2.1：let新特性</h4><h2><blockquote><p>不存在变量提升<br>暂时性死区<br>不允许重复声明<br>块级作用域</p></blockquote></h2><h4><a></a>2.2：const新特性</h4><h2><blockquote><p>不存在变量提升<br>暂时性死区<br>不允许重复声明<br>块级作用域<br>声明的变量不允许重新赋值<br>声明必须有初始化值</p></blockquote></h2><h4><a></a>2.2：let与const区别</h4><h2><blockquote><p>Let: 不存在变量提升<br>不允许重复声明<br>块级作用域</p></blockquote></h2><h2><a></a><a></a><a></a>三：组件的介绍</h2><h4><a></a>3.1：什么是组件</h4><h2><blockquote><p>一个应用/版块/页面中用于实现某个局部的功能(包括html, js, css等)<br>把这些局部功能组装到一起，就形成组件</p></blockquote></h2><h4><a></a>3.2：组件的类型</h4><h2><blockquote><p>组件分为有状态组件和无状态组件 无状态组件就是函数组件 有状态组件是类组件 区别在于是否含有state属性 下面给大家详细介绍一下有状态组件</p></blockquote></h2><h5><a></a>3.2.1：有状态组件（class组件）</h5><h2><ul><li><p>在类组件中 声明变量时，要把所有的变量都放到state对象中</p></li><li><p>放在state对象中 一是为了方便规范 ，二是标识符的规范 三是使用setstate实时更新数据</p></li><li><p>类组件中声明的函数 this指向问题 可以用箭头函数解决 也可以用bind（this）</p></li><li><p>操作渲染的DOM元素，使用ref属性 用this.refs.属性名 来获取值</p></li></ul></h2><h5><a></a>3.2.2：无状态组件（函数组件）</h5><h2></h2><h4><a></a>3.3：组件之间的关系</h4><h2><ul><li>父子组件</li><li>兄弟组件</li></ul></h2><h4><a></a>3.4：组件之间的通信 传值</h4><h5><a></a>3.4.1 父传子</h5><h2><blockquote><p>父组件 --&gt; 子组件 props属性<br>F.js 调用了 S.js , S.js中的数据是由 F.js决定的 通过标签（组件）的属性传值<br>F.js 引入 S.js<br>class F{<br>&lt;S 属性=值&gt;<br>}<br>S.js {this.props.属性}</p></blockquote><p>父组件代码示例如下：</p><p>子组件代码示例如下：</p></h2><h5><a></a>3.4.2 子传父</h5><h2><blockquote><p>子组件 --&gt; 父组件<br>1、在父组件中声明一个函数，用于接收子组件的传值<br>2、通过组件属性的方法，把函数传递给子组件<br>3、在子组件中通过props属性调用父组件的函数，并通过参数传值<br>4、在父组件中的函数通过形参接收子组件的传值</p></blockquote><p>父组件代码示例如下：</p><p>子组件代码示例如下：</p></h2><h5><a></a>3.4.3. 兄弟传值</h5><h2><blockquote><p>1、在父组件中声明一个函数，用于接收子组件的传值<br>2、通过组件属性的方法，把函数传递给子组件<br>3、在子组件中通过props属性调用父组件的函数，并通过参数传值<br>4、在父组件中的函数通过形参接收子组件的传值<br>5. 父组件再传给另一个儿子 通过构造方法 this.state接收 再用父传子的方法就可以了</p></blockquote><p>父组件代码示例如下：</p><p>子组件1代码示例如下：</p><p>子组件2代码示例如下：</p></h2><h3><a></a><a></a><a></a>四 refs属性介绍</h3><h2><blockquote><p>在React数据流中，父子组件唯一的交流方式是通过props属性；如果要修改子组件，通过修改父组件的属性，更新达到子组件props属性的值，重新渲染组件以达到视图的更新。但是，有些场景需要获取某一个真实的DOM元素来交互，比如文本框的聚焦、触发强制动画等</p></blockquote><ul><li>给DOM元素添加ref属性</li><li>给类组件添加ref属性</li></ul><p>子组件2代码示例如下：</p></h2><h3><a></a><a></a><a></a>五 ：路由之间的跳转</h3><h4><a></a>5.1 安装react-router-dom</h4><h2><p>*要注意：以下所有操作均运行在搭好的React环境中</p></h2><h4><a></a>5.2 引入路由相关组件</h4><h2><p>引入内置组件</p><ul><li>HashRouter表示一个路由的根容器，将来所有的路由相关的东西，都要包裹在HashRouter里面，而且一个网站中，只需要使用一次HashRouter就好了；</li><li>Route表示一个路由规则，在Route上，有两个比较重要的属性，path，component</li><li>Link表示一个路由的链接</li></ul><p>代码示例如下:</p></h2><h4><a></a>5.3嵌套路由</h4><h5><a></a>5.3.1 入口文件 代码示例：</h5><h2></h2><h5><a></a>5.3.2 一级路由 代码示例：</h5><h2></h2><h5><a></a>5.3.3 二级路由 代码示例：</h5><h2><p><img src=\"https://img-blog.csdnimg.cn/20191225145802936.png\" alt=\"跳转到这个路由中\"><br>代码示例如下：</p></h2><h3><a></a><a></a><a></a>六 redux介绍</h3><h4><a></a>6.1什么是redux</h4><h2><blockquote><p>Redux是一个流行的JavaScript框架，为应用程序提供一个可预测的状态容器。Redux基于简化版本的Flux框架，Flux是Facebook开发的一个框架。在标准的MVC框架中，数据可以在UI组件和存储之间双向流动，而Redux严格限制了数据只能在一个方向上流动</p></blockquote></h2><h4><a></a>6.2：配置Redux</h4><h2><p>创建store目录，在store目录下新建index.js文件，键入以下内容：</p><p>在store目录下创建reducer.js文件，键入以下内容：</p><p>在组件中就可以使用store的数据</p></h2>',0,'2020-12-14 16:08:47'),(14,'http://localhost:12345/static/uploadtextimg/timg.jpg','http://localhost:1234/static/uploadusertimg/timg.jpg','郝天恒2','react','react 入门必知必会知识点(万字总结✍)',' <h1>2020了，还不开始学react吗？| react 入门必知必会知识点(万字总结✍)</h1><h2><p><br></p><figure><img alt=\"title.png\" src=\"https://user-gold-cdn.xitu.io/2020/6/9/172968b7f9867836?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\"><figcaption></figcaption></figure><p><br></p><p>笔者从去年 12 月开始接触<code>react</code>，逐步由懵逼走向熟悉。不过<code>react</code>的需要掌握的知识点可真的有点多呢。所以花了很长一段时间来整理这样一篇<code>react</code>的基础知识总结的文章，以此达到温故知新的目的。文章会涉及到<code>react</code>本身的基础知识(包括组件通讯、生命周期、路由管理、状态管理等方面)，相信你认认真真看完这篇文章以后，你会对<code>react</code>开发有个大致的了解，并且能够快速入门。这篇文章也可用作面试复习 react 基础，并且这篇文章会持续更新，小伙伴们可以点个收藏，防止迷路。废话不多说，so ,Let\'s go!!!</p></h2><h2>组件通信</h2><h3>props</h3><h2><p>适用于父子组件通信</p></h2><h4>父组件-&gt;子组件</h4><h2><p>父组件将需要传递的参数通过<code>key={xxx}</code>方式传递至子组件，子组件通过<code>this.props.key</code>获取参数.</p><pre><code>import React from \'react\'\nimport Son from \'./son\'\nclass Father extends React.Component {\n  constructor(props) {\n    super(props)\n  }\n  state = {\n    info: \'父组件\',\n  }\n  handleChange = (e) =&gt; {\n    this.setState({\n      info: e.target.value,\n    })\n  }\n  render() {\n    return (\n      &lt;div&gt;\n        &lt;input type=\'text\' value={this.state.info} onChange={this.handleChange} /&gt;\n        &lt;Son info={this.state.info} /&gt;\n      &lt;/div&gt;\n    )\n  }\n}\nexport default Father\n\n// 子组件\nimport React from \'react\'\ninterface IProps {\n  info?: string\n}\nclass Son extends React.Component&lt;IProps&gt; {\n  constructor(props) {\n    super(props)\n  }\n  render() {\n    return (\n      &lt;div&gt;\n        &lt;p&gt;{this.props.info}&lt;/p&gt;\n      &lt;/div&gt;\n    )\n  }\n}\nexport default Son复制代码</code></pre></h2><h4>子组件-&gt;父组件</h4><h2><p>利用 props callback 通信，父组件传递一个 callback 到子组件，当事件触发时将参数放置到 callback 带回给父组件.</p><pre><code>// 父组件\nimport React from \'react\'\nimport Son from \'./son\'\nclass Father extends React.Component {\n  constructor(props) {\n    super(props)\n  }\n  state = {\n    info: \'\',\n  }\n  callback = (value) =&gt; {\n    // 此处的value便是子组件带回\n    this.setState({\n      info: value,\n    })\n  }\n  render() {\n    return (\n      &lt;div&gt;\n        &lt;p&gt;{this.state.info}&lt;/p&gt;\n        &lt;Son callback={this.callback} /&gt;\n      &lt;/div&gt;\n    )\n  }\n}\nexport default Father\n\n// 子组件\nimport React from \'react\'\ninterface IProps {\n  callback: (string) =&gt; void\n}\nclass Son extends React.Component&lt;IProps&gt; {\n  constructor(props) {\n    super(props)\n    this.handleChange = this.handleChange.bind(this)\n  }\n  handleChange = (e) =&gt; {\n    // 在此处将参数带回\n    this.props.callback(e.target.value)\n  }\n  render() {\n    return (\n      &lt;div&gt;\n        &lt;input type=\'text\' onChange={this.handleChange} /&gt;\n      &lt;/div&gt;\n    )\n  }\n}\nexport default Son复制代码</code></pre></h2><h3>Context</h3><h2><p>适用于跨层级组件之间通信</p><pre><code>// context.js\nimport React from \'react\'\nconst { Consumer, Provider } = React.createContext(null) //创建 context 并暴露Consumer和Provide\nexport { Consumer, Provider }\n\n// 父组件\nimport React from \'react\'\nimport Son from \'./son\'\nimport { Provider } from \'./context\'\nclass Father extends React.Component {\n  constructor(props) {\n    super(props)\n  }\n  state = {\n    info: \'info from father\',\n  }\n  render() {\n    return (\n      &lt;Provider value={this.state.info}&gt;\n        &lt;div&gt;\n          &lt;p&gt;{this.state.info}&lt;/p&gt;\n          &lt;Son /&gt;\n        &lt;/div&gt;\n      &lt;/Provider&gt;\n    )\n  }\n}\nexport default Father\n\n// 子组件\nimport React from \'react\'\nimport GrandSon from \'./grandson\'\nimport { Consumer } from \'./context\'\nclass Son extends React.Component {\n  constructor(props) {\n    super(props)\n  }\n  render() {\n    return (\n      &lt;Consumer&gt;\n        {(info) =&gt; (\n          // 通过Consumer直接获取父组件的值\n          &lt;div&gt;\n            &lt;p&gt;父组件的值:{info}&lt;/p&gt;\n            &lt;GrandSon /&gt;\n          &lt;/div&gt;\n        )}\n      &lt;/Consumer&gt;\n    )\n  }\n}\nexport default Son\n\n// 孙子组件\nimport React from \'react\'\nimport { Consumer } from \'./context\'\nclass GrandSon extends React.Component {\n  constructor(props) {\n    super(props)\n  }\n  render() {\n    return (\n      &lt;Consumer&gt;\n        {(info) =&gt; (\n          // 通过 Consumer 中可以直接获取组父组件的值\n          &lt;div&gt;\n            &lt;p&gt;组父组件的值:{info}&lt;/p&gt;\n          &lt;/div&gt;\n        )}\n      &lt;/Consumer&gt;\n    )\n  }\n}\nexport default GrandSon复制代码</code></pre><p>特别注意</p><blockquote><p>如果需要消费多个 Context,则 React 需要使每一个 consumer 组件的 context 在组件树中成为一个单独的节点。</p></blockquote><pre><code>// provider\n...\n  &lt;Context1.Provider value={this.state.info}&gt;\n    &lt;Context2.Provider value={this.state.theme}&gt;\n      &lt;div&gt;\n        &lt;p&gt;{this.state.info}&lt;/p&gt;\n        &lt;p&gt;{this.state.theme}&lt;/p&gt;\n        &lt;Son /&gt;\n      &lt;/div&gt;\n    &lt;/Context2.Provider&gt;\n  &lt;/Context1.Provider&gt;\n\n // consumer\n ...\n &lt;Context1.Consumer&gt;\n    {(info: string) =&gt; (\n      // 通过Consumer直接获取父组件的值\n      &lt;Context2.Consumer&gt;\n        {(theme: string) =&gt; (\n          &lt;div&gt;\n            &lt;p&gt;父组件info的值:{info}&lt;/p&gt;\n            &lt;p&gt;父组件theme的值:{theme}&lt;/p&gt;\n          &lt;/div&gt;\n        )}\n      &lt;/Context2.Consumer&gt;\n    )}\n  &lt;/Context1.Consumer&gt;复制代码</code></pre><blockquote><p>很多优秀的 React 组件的核心功能都通过 Context 来实现的，比如 react-redux 和 react-router 等，所以掌握 Context 是必须的。</p></blockquote></h2><h3>OnRef</h3><h2><p>OnRef 的原理很简单，本质上就是通过 props 将子组件的组件实例（也是我们常说的 this）当作参数，通过回调传到父组件，然后在父组件就可以拿到子组件的实例，拿到了它的实例就可以调用它的方法（<s>为所欲为</s>）了。</p><pre><code>// 父组件\nimport React from \'react\'\nimport Son from \'./son\'\nimport { Button } from \'antd\'\n\nclass Father extends React.Component {\n  child: any\n  constructor(props) {\n    super(props)\n  }\n  sonRef = (ref) =&gt; {\n    this.child = ref // 在这里拿到子组件的实例\n  }\n  clearSonInput = () =&gt; {\n    this.child.clearInput()\n  }\n  render() {\n    return (\n      &lt;div&gt;\n        &lt;Son onRef={this.sonRef} /&gt;\n        &lt;Button type=\'primary\' onClick={this.clearSonInput}&gt;\n          清空子组件的input\n        &lt;/Button&gt;\n      &lt;/div&gt;\n    )\n  }\n}\nexport default Father\n\n// 子组件\nimport React from \'react\'\nimport { Button } from \'antd\'\n\ninterface IProps {\n  onRef: any\n}\n\nclass Son extends React.Component&lt;IProps&gt; {\n  constructor(props) {\n    super(props)\n  }\n  componentDidMount() {\n    this.props.onRef(this) // 在这将子组件的实例传递给父组件this.props.onRef()方法\n  }\n  state = {\n    info: \'son\',\n  }\n  handleChange = (e) =&gt; {\n    this.setState({\n      info: e.target.value,\n    })\n  }\n  clearInput = () =&gt; {\n    this.setState({\n      info: \'\',\n    })\n  }\n  render() {\n    return (\n      &lt;div&gt;\n        &lt;div&gt;{this.state.info}&lt;/div&gt;\n        &lt;input type=\'text\' onChange={this.handleChange} /&gt;\n      &lt;/div&gt;\n    )\n  }\n}\nexport default Son复制代码</code></pre></h2><h3>ref</h3><h2><p><code>ref</code>是<code>react</code>提供给我们的一个属性,通过它，我们可以访问<code>DOM</code>节点或者组件.</p><pre><code>// 父组件\nimport React from \'react\'\nimport Son from \'./son\'\nimport { Button } from \'antd\'\n\nclass Father extends React.Component {\n  son: any\n  constructor(props) {\n    super(props)\n    this.son = React.createRef() // 在此处创建ref\n  }\n  clearSonInput = () =&gt; {\n    const { current } = this.son // 注意，这里必须通过 this.son.current拿到子组件的实例\n    current.clearInput()\n  }\n  render() {\n    return (\n      &lt;div&gt;\n        &lt;Son ref={this.son} /&gt;\n        &lt;Button type=\'primary\' onClick={this.clearSonInput}&gt;\n          清空子组件的input\n        &lt;/Button&gt;\n      &lt;/div&gt;\n    )\n  }\n}\nexport default Father\n\n// 子组件\nimport React from \'react\'\nimport { Button } from \'antd\'\n\nclass Son extends React.Component {\n  constructor(props) {\n    super(props)\n  }\n  state = {\n    info: \'son\',\n  }\n  handleChange = (e) =&gt; {\n    this.setState({\n      info: e.target.value,\n    })\n  }\n  clearInput = () =&gt; {\n    this.setState({\n      info: \'\',\n    })\n  }\n  render() {\n    return (\n      &lt;div&gt;\n        &lt;div&gt;{this.state.info}&lt;/div&gt;\n        &lt;input type=\'text\' onChange={this.handleChange} /&gt;\n      &lt;/div&gt;\n    )\n  }\n}\nexport default Son复制代码</code></pre><blockquote><p>值得注意的是，我们必须通过<code>this.childRef.current</code>才能拿到子组件的实例。<br>使用 ref 常见的场景有管理焦点，文本选择或媒体播放、触发强制动画、集成第三方 DOM 库等。</p></blockquote></h2><h3>第三方工具</h3><h4>events(发布订阅)</h4><h2><p>这种方式适用于没有任何嵌套关系的组件通信。其原理就是使用事件订阅。即是一个发布者，一个或者多个订阅者。 使用之前需要先安装:</p><pre><code>yarn add events复制代码</code></pre><pre><code>// event.ts\nimport { EventEmitter } from \'events\'\nexport default new EventEmitter()\n\n// 发布者 通过emit事件触发方法，发布订阅消息给订阅者\nimport React from \'react\'\nimport Son1 from \'./son1\'\nimport Son2 from \'./son2\'\nimport { Button } from \'antd\'\nimport emitter from \'./event\'\n\nclass Father extends React.Component {\n  son: any\n  constructor(props) {\n    super(props)\n  }\n  handleClick = () =&gt; {\n    //emit事件触发方法,通过事件名称找对应的事件处理函数info，将事件处理函数作为参数传入\n    emitter.emit(\'info\', \'我是来自father的 info\')\n  }\n  render() {\n    return (\n      &lt;div&gt;\n        &lt;Button type=\'primary\' onClick={this.handleClick}&gt;\n          点击按钮发布事件\n        &lt;/Button&gt;\n        &lt;Son1 /&gt;\n        &lt;Son2 /&gt;\n      &lt;/div&gt;\n    )\n  }\n}\nexport default Father\n\n// 订阅者1\n// 通过emitter.addListener(事件名称,函数名)方法，进行事件监听(订阅)。\n// 通过emitter.removeListener(事件名称,函数名)方法 ，进行事件销毁(取消订阅)\n\nimport React from \'react\'\nimport { Button } from \'antd\'\nimport emitter from \'./event\'\n\nclass Son1 extends React.Component {\n  constructor(props) {\n    super(props)\n  }\n  state = {\n    info: \'\',\n  }\n  componentDidMount() {\n    // 在组件挂载完成后开始监听\n    emitter.addListener(\'info\', (info) =&gt; {\n      this.setState({\n        info: \'Son1收到消息--\' + info,\n      })\n    })\n  }\n\n  componentWillUnmount() {\n    // 组件销毁前移除事件监听\n    emitter.removeListener(\'info\', (info) =&gt; {\n      this.setState({\n        info: \'Son1即将移除事件监听--\' + info,\n      })\n    })\n  }\n  render() {\n    return (\n      &lt;div&gt;\n        &lt;div&gt;{this.state.info}&lt;/div&gt;\n      &lt;/div&gt;\n    )\n  }\n}\nexport default Son1\n\n// 订阅者2\nimport React from \'react\'\nimport { Button } from \'antd\'\nimport emitter from \'./event\'\n\nclass Son2 extends React.Component {\n  constructor(props) {\n    super(props)\n  }\n  state = {\n    info: \'\',\n  }\n  componentDidMount() {\n    // 在组件挂载完成后开始监听\n    emitter.addListener(\'info\', (info) =&gt; {\n      this.setState({\n        info: \'Son2收到消息--\' + info,\n      })\n    })\n  }\n\n  componentWillUnmount() {\n    // 组件销毁前移除事件监听\n    emitter.removeListener(\'info\', (info) =&gt; {\n      this.setState({\n        info: \'Son2即将移除事件监听--\' + info,\n      })\n    })\n  }\n  render() {\n    return (\n      &lt;div&gt;\n        &lt;div&gt;{this.state.info}&lt;/div&gt;\n      &lt;/div&gt;\n    )\n  }\n}\nexport default Son2复制代码</code></pre></h2><h2>路由</h2><h2><p>随着前端工程的复杂度越来越高，所以路由管理在现在的前端工程中，也是一个值得注意的点，<code>vue</code>提供了<code>vue-router</code>来管理路由。相似的，<code>react</code>则提供了<code>react-router</code>来管理路由。</p></h2><h3><code>react-router</code></h3><h2><p><code>react-router</code>包含<code>3</code>个，分别为<code>react-router</code>、<code>react-router-dom</code>和<code>react-router-native</code>。</p><p><code>react-router</code>提供最基本的路由功能，但是实际使用的时候我们不会直接安装<code>react-router</code>，而是根据应用运行的环境来选择安装<code>react-router-dom</code>和<code>react-router-native</code>。因为<code>react-router-dom</code>和<code>react-router-native</code>都依赖<code>react-router</code>，所以在安装时，<code>react-router</code>也会⾃自动安装。</p><p>其中<code>react-router-dom</code>在浏览器器中使⽤，而<code>react-router-native</code>在<code>react-native</code>中使用。</p><p>在 react-router 里面，一共有 3 种基础组件，他们分别是</p><ul><li>路由组件(router components) 比如<code>&lt;BrowserRouter&gt;</code>和<code>&lt;HashRouter&gt;</code></li><li>路由匹配组件(route matchers components) 比如<code>&lt;Route&gt;</code>和<code>&lt;Switch&gt;</code></li><li>导航组件(navigation components) 比如<code>&lt;Link&gt;</code>,<code>&lt;NavLink&gt;</code>, 和<code>&lt;Redirect&gt;</code></li></ul></h2><h3>路由组件</h3><h2><p>对于 web 项目，react-roruter-dom 提供了<code>&lt;BrowserRouter&gt;</code>和<code>&lt;HashRouter&gt;</code>两个路由组件。</p><ul><li><code>BrowserRouter</code>：浏览器的路由方式，也就是使用<code>HTML5</code>提供的<a target=\"_blank\" href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/History\"><code>history API</code></a>( pushState , replaceState 和 popstate 事件) 来保持<code>UI</code>和<code>url</code>的同步。这种方式在<code>react</code>开发中是经常使用的路由方式，但是在打包后，打开会发现访问不了页面，所以需要通过配置<code>nginx</code>解决或者后台配置代理。</li><li><code>HashRouter</code>：在路径前加入#号成为一个哈希值，<code>Hash</code>模式的好处是，再也不会因为我们刷新而找不到我们的对应路径，但是链接上面会有<code>#/</code>。在<code>vue</code>开发中，经常使用这种方式。</li></ul><p>要使用路由组件，我们只需要确保它是在根组件使用，我们应该将<code>&lt;App /&gt;</code>包裹在路由组件下面：</p><pre><code>import { BrowserRouter } from \'react-router-dom\';\n...\n&lt;BrowserRouter&gt;\n    &lt;App /&gt;\n&lt;/BrowserRouter&gt;\n...复制代码</code></pre></h2><h3>匹配组件</h3><h2><p>有两种路由匹配组件：<code>&lt;Route&gt;</code>和<code>&lt;Switch&gt;</code></p><p>这两个路由匹配组件通常在一起使用，在<code>&lt;Switch&gt;</code>里面包裹多个<code>&lt;Route&gt;</code>，然后它会逐步去比对每个<code>&lt;Route&gt;</code>的<code>path</code>属性 和浏览器当前<code>location</code>的<code>pathname</code>是否一致，如果一致则返回内容，否则返回<code>null</code>。</p><pre><code>&lt;Switch&gt;\n  &lt;Route exact path=\'/\' component={Home} /&gt;\n  {/* 如果当前的URL是`/about`,即 location = { pathname: \'/about\' } ,那么About组件就应该被渲染，其余的Route就会被忽略 */\n  &lt;Route path=\'/about\' component={About} /&gt;\n  &lt;Route path=\'/contact\' component={Contact} /&gt;\n&lt;/Switch&gt;复制代码</code></pre><p>值得注意 ⚠️ 的是：<code>&lt;Route path={xxx}&gt;</code>只会匹配<code>URL</code>的开头，而不是整个 URL。简单的来说就是它不是精确匹配 ，例如<code>&lt;Route path =\'/\'&gt;</code>和<code>&lt;Route path =\'/about\'&gt;</code>它永远都只能匹配到<code>&lt;Route path =\'/\'&gt;</code>,他们开头都有\'/\'。<br>在这里我们有两种解决方法：</p><ul><li>将此<code>&lt;Route path=\'/\'&gt;</code>放在<code>&lt;Switch&gt;</code>的最后一个位置</li><li>另一种解决方案是添加\'exact\' 实现精确匹配：<code>&lt;Route exact=\'/\'&gt;</code></li></ul><p>所以<code>&lt;Switch&gt;</code>组件只会<code>render</code>第一个匹配到的路由，像上面我们说的，如果没有设置<code>path</code>，则一定会匹配，我们可以用来实现 404 的功能:</p><pre><code>&lt;Switch&gt;\n  &lt;Route exact path=\'/\' component={Home} /&gt;\n  &lt;Route path=\'/about\' component={About} /&gt;\n  &lt;Route path=\'/contact\' component={Contact} /&gt;\n  {/* 当上面的组件都没有匹配到的时候, 404页面 就会被 render */}\n  &lt;Route render={() =&gt; &lt;div&gt; 404页面 &lt;/div&gt;} /&gt;\n&lt;/Switch&gt;复制代码</code></pre></h2><h3>导航组件</h3><h2><p>导航组件有<code>&lt;Link&gt;</code>,<code>&lt;NavLink&gt;</code>, 和<code>&lt;Redirect&gt;</code>。</p><p>当我们使用<code>&lt;Link&gt;</code>的时候，在 html 页面会被渲染为一个<code>a</code>标签:</p><pre><code>&lt;Link to=\'/\'&gt;Home&lt;/Link&gt;\n// &lt;a href=\'/\'&gt;Home&lt;/a&gt;复制代码</code></pre><p><code>&lt;NavLink&gt;</code>是一种特殊的<code>&lt;Link&gt;</code>，当<code>&lt;NavLink&gt;</code>中的地址和浏览器地址匹配成功的时候，会添加一个 style 样式，如下：</p><pre><code>&lt;NavLink to=\'/about\' activeClassName=\'active\'&gt;\n  About\n&lt;/NavLink&gt;复制代码</code></pre><p>在 html 页面当中，它会被渲染为:</p><pre><code>&lt;a href=\'/about\' className=\'active\'&gt;\n  About\n&lt;/a&gt;复制代码</code></pre><p>但是有时你可能想要强制跳转到某个页面，比如未登录不能进入首页，这个时候你可以使用<code>&lt;Redirect&gt;</code></p><pre><code>&lt;Redirect to=\'/login\' /&gt;复制代码</code></pre></h2><h2>状态管理</h2><h2><p>前端工程的复杂度越来越高，状态管理也是一个很重要的点。在 react 生态中，现在最火的状态管理方案就是<code>redux</code>。</p></h2><h3>redux</h3><h2><p>我们都知道，react 是单向的数据流，数据几乎都是通过 props 依次从上往下传:</p><figure><img alt=\"react-porps.gif\" src=\"data:image/svg+xml;utf8,<?xml version=&quot;1.0&quot;?><svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;550&quot; height=&quot;300&quot;></svg>\"><figcaption></figcaption></figure><p><br></p><blockquote><p>图片来自<a target=\"_blank\" href=\"https://medium.com/dailyjs/when-do-i-know-im-ready-for-redux-f34da253c85f\">When do I know I’m ready for Redux?</a></p></blockquote><p>一个组件的状态有两种方式改变：</p><ul><li>来自父组件的 props 改变了，那么这个组件也会重新渲染</li><li>自身有 state，自身的 state 可以通过<code>this.setstate</code>方法改变</li></ul><p>现在假如我们组件树的层级比较深，有很多子组件需要共享状态，那么我们只能通过状态提升来改变状态，将状态提升到顶级父组件改变，当顶级父组件的状态改变了，那么旗下的所有子节点都会重新渲染：</p><p><br></p><figure><img alt=\"state-change.gif\" src=\"data:image/svg+xml;utf8,<?xml version=&quot;1.0&quot;?><svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;550&quot; height=&quot;475&quot;></svg>\"><figcaption></figcaption></figure><p><br></p><p>当出现这种情况当时候，你就该使用<code>redux</code>了。那么使用<code>redux</code>之后，就会变成这样：</p><p><br></p><figure><img alt=\"redux-state.gif\" src=\"data:image/svg+xml;utf8,<?xml version=&quot;1.0&quot;?><svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;700&quot; height=&quot;475&quot;></svg>\"><figcaption></figcaption></figure><p><br></p><p>以上 gif 动图很生动的展示了 redux 解决的问题，下面我们来介绍一下 redux 相关的知识点：</p></h2><h4>Store</h4><h2><p>在 redux 里面，只有一个<code>Store</code>，整个应用需要管理的数据都在这个<code>Store</code>里面。这个<code>Store</code>我们不能直接去改变，我们只能通过返回一个新的<code>Store</code>去更改它。<code>redux</code>提供了一个<code>createStore</code>来创建<code>state</code></p><pre><code>import{ createStore }from\'redux\'conststore = createStore(reducer)复制代码</code></pre></h2><h4>action</h4><h2><p>这个<code>action</code>指的是视图层发起的一个操作，告诉<code>Store</code>我们需要改变。比如用户点击了按钮，我们就要去请求列表，列表的数据就会变更。每个<code>action</code>必须有一个<code>type</code>属性，这表示<code>action</code>的名称，然后还可以有一个<code>payload</code>属性，这个属性可以带一些参数，用作<code>Store</code>变更：</p><pre><code>constaction = {type:\'ADD_ITEM\',\n  payload:\'new item\',// 可选属性}复制代码</code></pre><p>上面这个例子就定义了一个名为<code>ADD_ITEM</code>的<code>Action</code>，它还携带了一个<code>payload</code>的参数。<code>Redux</code>可以用<code>Action Creator</code>批量来生成一些<code>Action</code>。</p></h2><h4>reducer</h4><h2><p>在上面我们定义了一个<code>Action</code>,但是<code>Action</code>不会自己主动发出变更操作到<code>Store</code>，所以这里我们需要一个叫<code>dispatch</code>的东西，它专门用来发出<code>action</code>，不过还好，这个<code>dispatch</code>不需要我们自己定义和实现，<code>redux</code>已经帮我们写好了，在<code>redux</code>里面，<code>store.dispatch()</code>是<code>View</code>发出<code>Action</code>的唯一方法。</p><pre><code>store.dispatch({type:\'ADD_ITEM\',\n  payload:\'new item\',// 可选属性})复制代码</code></pre><p>当<code>dispatch</code>发起了一个<code>action</code>之后，会到达<code>reducer</code>，那么这个<code>reducer</code>用来干什么呢？顾名思义，这个<code>reducer</code>就是用来计算新的<code>store</code>的，<code>reducer</code>接收两个参数：当前的<code>state</code>和接收到的<code>action</code>，然后它经过计算，会返回一个新的<code>state</code>。(前面我们已经说过了，不能直接更改<code>state</code>，必须通过返回一个新的<code>state</code>来进行变更。)</p><pre><code>constreducer =function(prevState, action){\n  ...returnnewState;\n};复制代码</code></pre><p>这个<code>reducer</code>是一个纯函数。纯函数的意思是说，对于相同的输入，只会有相同的输出，不会影响外部的值，也不会被外部的值所影响。纯函数属于函数式编程的概念，如果你想了解更多纯函数的概念，请看<a target=\"_blank\" href=\"https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch3.html#%E8%BF%BD%E6%B1%82%E2%80%9C%E7%BA%AF%E2%80%9D%E7%9A%84%E7%90%86%E7%94%B1\">这里</a></p><p>可以看到，我们在创建<code>store</code>的时候，我们在<code>createStore</code>里面传入了一个<code>reducer</code>参数，在这里，我们就是为了，每次<code>store.dispatch</code>发送一个新的<code>action</code>,<code>redux</code>都会自动调用<code>reducer</code>，返回新的<code>state</code>。</p><p>那么当项目特别大特别复杂的时候，<code>state</code>肯定是非常大的一个对象，所以我们需要写很多个<code>reducer</code>，那么在这里，我们就需要把<code>reducer</code>进行拆分。每个<code>reducer</code>只负责管理<code>state</code>的一部分数据。那么我们如何统一对这些<code>reducer</code>进行管理呢？<code>redux</code>给我们提供了<code>combineReducers</code>方法，顾名思义，就是将所有的子<code>reducer</code>合成一个<code>reducer</code>，方便我们管理。</p><pre><code>import{ combineReducers }from\'redux\'importlistReducerfrom\'./listReducer/reducers\'importdetailReducerfrom\'./detailReducer/reducers\'importaboutReducerfrom\'./aboutReducer/reducers\'constrootReducer = combineReducers({\n  listReducer,\n  detailReducer,\n  aboutReducer,\n})exportdefaultrootReducer复制代码</code></pre></h2><h4>中间件</h4><h2><p>熟悉<code>koa</code>的朋友们，应该知道中间件的概念。中间件的意思简单理解就是，在某两个操作之间，我们需要进行某些操作。那么在 redux,我们为什么要引入中间件呢？到目前为止，我们来捋一下我们刚刚已经进行的步骤：</p><ol><li>创建 store</li></ol><pre><code>import{ createStore }from\'redux\'conststore = createStore(reducer)复制代码</code></pre><ol><li>发出 action</li></ol><pre><code>store.dispatch({type:\'ADD_ITEM\',\n  payload:\'new item\',// 可选属性})复制代码</code></pre><ol><li>reducer 计算返回新的 state</li></ol><pre><code>constreducer =function(prevState, action){\n  ...returnnewState;\n};复制代码</code></pre><p>我们发现，我们这次发起的变更，都是同步操作，那么问题来了。假如我们<code>state</code>里面有一个列表：<code>list</code>，用户根据在<code>view</code>上面点击了一些筛选条件，发起请求，然后变更<code>state</code>里面<code>list</code>的值。在这里，有异步请求，但是我们变更 redux 的过程都是同步的，显然是不支持异步的，所以这里就用到中间件了。那么我们应该将异步请求放在以上哪个步骤去执行呢？显然第 1 步和第 3 步不可能，其中第 1 步只是在创建<code>store</code>，第 3 步<code>reducer</code>是纯函数，根本不可能加入异步操作。所以我们很自然的想到，就是在<code>store.dispatch</code>的之后，到达<code>reducer</code>之前进行异步操作：</p><pre><code>store.dispatch =function(prevAction)async{console.log(\"发请求啦\");// 异步操作执行完成之后才派发actionconstlist =awaitgetList();// 把 list 放到action里面constnewAction = {type: prevAction.type,\n    payload:list\n  }\n  store.dispatch(newAction);\n};复制代码</code></pre><p>就是给<code>store.dispatch</code>再包裹一层，这就是中间件的原理。 redux 常见的中间件有<code>redux-thunx</code>、<code>redux-promise</code>、<code>redux-saga</code>。相关的详细用法在这里不再赘述(下面会介绍<code>dva-core</code>的用法)。 redux 应用中间件的方法：</p><pre><code>import{ applyMiddleware, createStore }from\'redux\'importmyMiddlewarefrom\'./myMiddleware\'conststore = createStore(reducer, applyMiddleware(myMiddleware))复制代码</code></pre></h2><h4>通知变更</h4><h2><p>那么到这一步了，我们变更了<code>state</code>，下一步是将变更通知给<code>view</code>了。在 redux 里面，提供了<code>store.subscribe(listener)</code>这个方法,这个方法传入一个<code>listener</code>,比如在<code>react</code>里面，<code>listener</code>可以是<code>this.setState(xxx)</code>,每当<code>redux</code>里面的<code>state</code>改变了，通过<code>store.subscribe(listener)</code>我们的页面也会重新渲染。意思是我们每个页面都得手动去<code>store.subscribe(listener)</code>，这也太麻烦了吧，对吧。</p></h2><h3><code>react-redux</code>和<code>redux</code></h3><h2><p>为了解决上述的痛点问题，更好的将<code>redux</code>和<code>react</code>结合，官方给我们提供了<code>react-redux</code>这个包（可能你到现在脑子有点乱了，我刚开始也是）。那么现在，我们需要明确一个概念：<code>redux</code>和<code>react</code>是两个八竿子不着的人。<code>redux</code>只是一个状态管理框架，<code>react</code>只是一个前端应用框架。<code>redux</code>可以用于前端任何框架，例如<code>vue</code>，甚至纯<code>javaScript</code>都可以。后来<code>react-redux</code>出现了，他把<code>redux</code>和<code>react</code>撮合在一起了，于是他们两强强联合，风云合璧，所向披靡，好了不扯了。说了这么多就是想说明<code>react-redux</code>这个包的作用。</p><p>在详细说明<code>react-redux</code>的作用之前，我们先介绍以下知识点：<code>react-redux</code>将 react 组件划分为<code>容器组件</code>和<code>展示组件</code>，其中</p><ul><li>展示组件：只是负责展示 UI，不涉及到逻辑的处理，数据来自父组件的<code>props</code>;</li><li>容器组件：负责逻辑、数据交互，将 state 里面的数据传递给<code>展示组件</code>进行 UI 呈现</li></ul><p>容器组件是<code>react-redux</code>提供的，也就是说，我们只需要负责展示组件，<code>react-redux</code>负责状态管理。</p><p>我们知道，<code>redux</code>提供了一个大的<code>state</code>。这里我们需要面对两个问题，第一个问题，如何让我们<code>react</code>项目里面的所有组件都能够拿到<code>state</code>？；第二个，每当<code>state</code>变更之后，组件如何收到变更信息？</p></h2><h5><code>Provider</code></h5><h2><p>针对第一个问题，<code>react-redux</code>提供了<code>Provider</code>组件。用这个<code>Provider</code>包裹根组件，将<code>redux</code>导出的<code>state</code>，作为参数往下面传</p><pre><code>import React from \"react\";\n\nimport { Provider } from \"react-redux\";\nimport App from \"./App\";\nimport { store } from \"./store\"; // 这个store由redux导出\n···\n&lt;Provider store={store}&gt;\n  &lt;App /&gt;\n&lt;/Provider&gt;;\n···\nreturn复制代码</code></pre><p>这样所有的组件都能拿到<code>state</code>了。这个 Provider 组件原理就是通过<code>react</code>的<code>Context</code>来实现的，我们可以看看源码:</p><pre><code>....\nconst Context = context || ReactReduxContext;\nreturn &lt;Context.Provider value={contextValue}&gt;{children}&lt;/Context.Provider&gt;;\n....复制代码</code></pre><p>这里的<code>contextValue</code>就包裹了我们传入的<code>store</code>，很明显，它创建了 Context，通过<code>&lt;Context.Provider value={contextValue}&gt;{children}&lt;/Context.Provider&gt;</code>这种方式将我们传入的<code>store</code>提供给了<code>react</code>所有组件。</p></h2><h5><code>connect</code></h5><h2><p>在上面我们知道怎么将 redux 暴露出来的 state 提供给 react 组件的，那么接下来，我们在某个子组件里面如何收到 state 的变更呢？<code>react-redux</code>给我们提供了<code>connect</code>方法。这个方法可以传入两个可选参数:<code>mapStateToProps</code>和<code>mapDispatchToProps</code>，然后会返回一个容器组件，这个组件可以自动监听到<code>state</code>的变更，将<code>state</code>的值映射为组件的<code>props</code>参数，之后我们可以直接通过<code>this.props</code>取到<code>state</code>里面的值。</p><pre><code>const mapStateToProps = (state) =&gt; ({\n  goodsList: state.goodsList,\n  totalCount: state.totalCount,\n});\n\nexport default connect(\n  mapStateToProps, // 可选\n// mapDispatchToProps, // 可选\n(GoodsList);复制代码</code></pre><p><code>mapStateToProps</code>就是将 state 的值映射为组件的<code>props</code>，<code>mapDispatchToProps</code>就是将<code>store.dispatch</code>映射为<code>props</code>。如果我们不传<code>mapDispatchToProps</code>的话，<code>connect</code>会自动将<code>dispatch</code>注入到<code>props</code>里面，我们在组件里可以直接通过<code>this.props.dispatch</code>发起一个<code>action</code>给<code>reducer</code>。</p></h2><h3><code>connected-react-router</code>和<code>redux</code></h3><h2><p>当我们在项目中同时用了<code>react-router</code>和<code>redux</code>的时候，我们可以把他们两个深度整合。我们想要在<code>store</code>里面拿到<code>router</code>，甚至可以操作<code>router</code>，还可以记录<code>router</code>的改变。例如我们把用户是否登录的状态存在<code>redux</code>里面，在登录之后会进行页面的跳转。正常的操作是我们在发起请求之后，得到一个状态，此时我们需要<code>dispatch</code>一个<code>action</code>去改变<code>redux</code>的状态，同时我们需要进行路由的跳转，类似于这样:<code>store.dispatch(replace(\'/home\'))</code>。想要实现这种深度整合，我们需要用到<code>connected-react-router</code>和<code>history</code>两个库。</p><p>首先需要<code>history</code>生成<code>history</code>对象，结合<code>connected-react-router</code>的<code>connectRouter</code>生成<code>routerReducer</code>，同时利用<code>connected-react-router</code>的<code>routerMiddleware</code>实现<code>dispatch action</code>导航，也就是我们刚刚说的<code>store.dispatch(replace(\'/home\'))</code>:</p><pre><code>// APP.tsx\nconst createHistory = require(\'history\').createBrowserHistory\nexport const history = createHistory()\n\n// reducer/index.ts\nconst routerReducer = connectRouter(history)\nconst routerMiddlewareForDispatch = routerMiddleware(history)\nconst middleware = [routerMiddlewareForDispatch]复制代码</code></pre><p>接着利用<code>redux</code>的<code>combineReducers</code>将我们自己的<code>reducer</code>和<code>routerReducer</code>合并起来，组成<code>rootReducer</code>，然后利用<code>createStore</code>创建<code>store</code>并暴露出去:</p><pre><code>// reducer/index.ts\nexport default function geneGrateSotore(history: any) {\n  const routerReducer = connectRouter(history)\n  const routerMiddlewareForDispatch = routerMiddleware(history)\n  const middleware = [routerMiddlewareForDispatch]\n  //合并routerReducer\n  const rootRuder = combineReducers({\n    info: infoRuder,\n    router: routerReducer,\n  })\n\n  const store = createStore(rootRuder, applyMiddleware(...middleware))\n  return store\n}复制代码</code></pre><p>最后我们在<code>App.tsx</code>导入刚刚我们创建的这个方法，生成<code>store</code>,接着将我们创建的<code>history</code>对象传入<code>connected-react-router</code>的<code>ConnectedRouter</code>组件作为<code>props</code>，并用它包裹我们的<code>Router</code>组件:</p><pre><code>// App.tsx\nimport React from \'react\'\nimport { Provider } from \'react-redux\'\nimport { ConnectedRouter } from \'connected-react-router\'\nimport geneGrateSotore from \'./store\'\nimport Router from \'./router\'\nimport \'./App.css\'\n\nconst createHistory = require(\'history\').createBrowserHistory\nconst history = createHistory()\nconst store = geneGrateSotore(history)\n\nconst f: React.FC = () =&gt; {\n  return (\n    &lt;Provider store={store}&gt;\n      &lt;ConnectedRouter history={history}&gt;\n        &lt;Router&gt;&lt;/Router&gt;\n      &lt;/ConnectedRouter&gt;\n    &lt;/Provider&gt;\n  )\n}\n\nexport default f复制代码</code></pre><p>这样我们就将<code>connected-react-router</code>和<code>redux</code>整合起来了。现在当我们在<code>View</code>利用<code>Link</code>进行路由跳转的时候，会通过<code>react-router-dom</code>进行路由跳转，并且也会通过<code>connected-react-router</code>发起一个<code>action</code>去更新<code>redux state</code>里面的<code>router</code>对象，以记录路由的变化。同时现在我们在状态管理的时候，也可以直接通过<code>connected-react-router</code>提供的<code>push</code>、<code>replace</code>等方法了，他们是从<code>redux</code>出发，也就是说先发起一个<code>action</code>，然后再进行路由跳转。</p></h2><h3>小结一下</h3><h2><p>看了上面的这些东西，是不是感觉脑子贼乱，什么<code>react</code>、<code>redux</code>、<code>react-redux</code>、<code>react-router</code>、<code>react-router-dom</code>、<code>connected-react-router</code>，这些概念是真的多，我刚开始接触的时候直接看懵逼。。所以 react 的可组合性比 vue 高很多，所以说 vue 真的是自动挡、react 是手动挡。但是我们只需记住，前端的一切概念，都是纸老虎而已。静下心来捋一捋，很快就理解了。好了，现在来看看这个图：</p><p><br></p><figure><img alt=\"react.png\" src=\"data:image/svg+xml;utf8,<?xml version=&quot;1.0&quot;?><svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;1280&quot; height=&quot;723&quot;></svg>\"><figcaption></figcaption></figure><p><br></p><p>结合上面介绍的知识点，把思路捋顺，咱们再继续 ',0,'2020-12-14 16:10:22'),(64,'http://localhost:1234/static/uploadtextimg/2020-12-14_20-55-13_36399.jpg','http://localhost:1234/static/uploadusertimg/timg.jpg','郝天恒','react','123123','<p>12313</p>',0,'2020-12-14 20:55:13');

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;
